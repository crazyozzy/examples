# Основы
## Целые числа
В Go существуют следующие типы целых чисел: `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32` и `int64`.
8, 16, 32 и 64 говорит нам, сколько бит использует каждый тип.
`uint` означает «unsigned integer» (беззнаковое целое), в то время как `int` означает «signed integer» (знаковое целое).
Беззнаковое целое может принимать только положительные значения (или ноль).


| Тип     | Описание                               | Принимаемые значения |
|---------|----------------------------------------| --- |
| uint8   | Беззнаковые 8-битные целые числа       |    от 0 до 255
| uint16  | Беззнаковые 16-битные целые числа      |    от 0 до 65535
| uint32  | Беззнаковые 32-битные целые числа      |	от 0 до 4294967295
| uint64  | 	Беззнаковые 64-битные целые числа  | 	от 0 до 18446744073709551615
| int8    | 	Знаковые 8-битные целые числа      |	от -128 до 127
| int16   | 	Знаковые 16-битные целые числа     | 	от -32768 до 32767
| int32   | 	Знаковые 32-битные целые числа     | 	от -2147483648 до 2147483647
| int64   | 	Знаковые 64-битные целые числа     | 	от -9223372036854775808 до 9223372036854775807

В дополнение к этому существуют два типа-псевдонима: `byte` (то же самое, что `uint8`) и `rune` (то же самое, что `int32`).
Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип `byte` в Go часто используется для определения других типов.

Также существует 3 машинно-зависимых целочисленных типа: `uint`, `int` и `uintptr`.
Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера:

`int`: представляет целое число со знаком, которое в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо `int32`, либо `int64`.

`uint`: представляет целое число только без знака, которое, аналогично типу `int`, в зависимости от платформы может занимать либо 4 байта, либо 8 байт.
То есть соответствовать либо `uint32`, либо `uint64`.

В общем, если вы работаете с целыми числами — просто используйте тип `int`.


## Числа с плавающей точкой
**Числа с плавающей точкой** — это числа, которые содержат вещественную часть (вещественные числа) (1.234, 123.4, 0.00001234).
* Числа с плавающей точкой неточны. Бывают случаи, когда число вообще нельзя представить. Например, результатом вычисления 1.01 - 0.99 будет0.020000000000000018 - число очень близкое к ожидаемому, но не то же самое.
* Как и целые числа, числа с плавающей точкой имеют определенный размер (32 бита или 64 бита). Использование большего размера увеличивает точность (сколько цифр мы можем использовать для вычисления)
* В дополнение к числам существуют несколько других значений, таких как:  (`NaN`, для вещей наподобие 0/0), а также положительная и отрицательная бесконечность (`+∞` и `−∞`).

В Go есть два вещественных типа: `float32` и `float64` (соответственно часто называемые вещественными числами с одинарной и двойной точностью), а также два дополнительных типа для представления комплексных чисел (чисел с мнимой частью): `complex64` и `complex128`.
При работе с вещественными числами достаточно использовать `float32`, однако, если Вы хотите работать с более точными числами, можно использовать и `float64`. 


## Строки
Строка — это последовательность символов определенной длины, используемая для представления текста.
Строки в Go состоят из независимых байтов, обычно по одному на каждый символ (символы из других языков, таких как китайский, представляются несколькими байтами).

Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов \`Hello World\`.
Различие между ними в том, что строки в двойных кавычках не могут содержать новые строки и они позволяют использовать особые управляющие последовательности символов.
Например, `\n` будет заменена символом новой строки, а `\t` - символом табуляции.

Распространенные операции над строками включают в себя нахождение количества байт строки `len("Hello World")`, доступ к отдельному символу в строке `"Hello World"[1]` (строки “индексируются” начиная с 0, а не с 1), и конкатенацию двух строк `"Hello " + "World"`.

Так как строки в Go хранятся в виде байтов нужно понимать что такой код не выведет символ:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello Go"[0]) // вывод: 72
}
```

Представим байты в виде строки:
```go
package main

import "fmt"

func main() {
    fmt.Println(string("Hello Go"[0])) // вывод: H
}
```


## Логические типы
Булевый тип - `bool` (названный так в честь Джорджа Буля) — это специальный целочисленный тип, используемый для представления истинности и ложности.
Переменная такого типа будет занимать только один байт.
С этим типом используются три логических оператора:

| Литерал       | Пояснение |
|---------------|-----------|
| &&            | И         |
| &#124;&#124;  | 	ИЛИ      |
| !             | 	НЕ       |

Переменная типа `bool` может принимать только два значения: `truе` или `false`.


## Переменные
Для определения переменной применяется ключевое слово var, после которого идет имя переменной, а затем указывается ее тип:
```
var имя_переменной тип_данных
```

Имя переменной представляет произвольный идентификатор, который состоит из алфавитных и цифровых символов и символа подчеркивания. При этом первым символом должен быть либо алфавитный символ, либо символ подчеркивания.

При этом имена не должны представлять одно из ключевых слов: `break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var`.

Можно одновременно объявить сразу несколько переменных через запятую:
```go
var a, b, c string
```

Для хранения символов можно использовать `int32`/`rune`.
Здесь используются одинарные кавычки.
Компилятор определяет код буквы в unicode и присваивает его переменной symbol.
То есть мы не храним никакую 'c', а храним лишь число 99.
Функция `string()` из переданного в него числа 99 делает строку 'c'.
```go
var symbol int32 = 'c'
fmt.Println(string(symbol))
```

Также можно объявить сразу несколько переменных в одном блоке var:
```go
var (
    name string = "Dima"
    age int = 23
)
```


## Арифметические операции
У переменных есть разные операции, как в алгебре.
* \+ сложение
* \- вычитание
* \* умножение
* / деление
* % остаток от деления
* x++ инкремент
* x-- декремент


При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:
```go
var a int = 10 / 6
------------------
Вывод: 1
```

Чтобы получить в результате деления вещественное число,  как минимум один из операндов также должен представлять собой вещественное число и результат мы должны при этом тоже сохранять в переменную вещественного типа:
```go
var m float32 = 10.0 / 6
----------------------
Вывод: 1.6666666
```


## Константы
Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз.
Вычисление констант производится во время компиляции.
Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Для определения констант применяется ключевое слово `const`:
```go
const pi float64 = 3.1415
```

Константы, как и обычные переменные, можно объявлять в блоке:
```go
const (
	a int = 45
	b float32 = 3.3
)
```

Также можно не указывать значение следующей константы по порядку (значение будет скопировано):
```go
package main

import (
	"fmt"
)

const(
	A int = 45
	B
	C float32 = 3.3
	D
)

func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}
```


## iota
**iota** идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.

Сделаем дни недели с использованием iota - теперь это выглядит проще (особенно если много данных):  
```go
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

func main() {
	fmt.Println(Sunday)   // вывод 0
	fmt.Println(Saturday) // вывод 6
}
```

В объявлении константы предварительно объявленный идентификатор iota представляет последовательные не типизированные целочисленные константы.
Его значение является индексом соответствующего ConstSpec в объявлении константы, начиная с нуля.
Поскольку он может использоваться в выражениях, он обеспечивает общность, выходящую за рамки простых перечислений.
Его можно использовать для построения набора связанных констант, ознакомьтесь с примерами:
```go
const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2


const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8



const (
	u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0
```


## Условные выражения
Условные выражения представляют операции отношения и логические операции.
Они представляют некоторое условие и возвращают значение типа `bool`: `true` (если условие истинно) или `false` (если условие ложно).

### Операции отношения
Операции отношения позволяют сравнить два значения.
В языке Go есть следующие операции отношения:
* ==
* \>
* <
* <=
* \>=
* !=

### Логические операции
Логические операции сравнивают два условия.
Как правило, они применяются к отношениям и объединяют несколько операций отношения.

К логическим операциям относят следующие:
* ! (операция отрицания, логическое НЕ)
* && (конъюнкция, логическое умножение,  логическое И)
* || (дизъюнкция, логическое сложение, логическое ИЛИ)


## Условные конструкции
### Условная конструкция if
Конструкция if принимает условие - выражение, которое возвращает значение типа `bool`.
Если это условие истинно, то выполняется последующий блок инструкций:
```go
package main

import "fmt"

func main() {
   a := 6    
   b := 7
   if a < b {     
      fmt.Println("a меньше, чем b")  
   }
}
```

### If с краткой инструкцией

Так же как и `for` (про него в следующем уроке), оператор `if` может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные, объявленные в этом блоке, доступны только в области видимости, которая существует до конца `if`.
Пример:
```go
if v := math.Pow(x, n); v < lim {
   // ...
}
```

### Условные конструкции else if и else
Если нам нужно проверить несколько условий, мы можем использовать оператор `else if`:
```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
}
```

Если нам нужен вариант, когда ни одно из условий не выполняется, то мы используем оператор `else`:
```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}
```

### Switch
Go содержит в себе другой оператор, позволяющий делать перечисления: оператор switch (переключатель).
С ним программа может выглядеть так:
```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

Переключатель начинается с ключевого слова `switch`, за которым следует выражение (в нашем случае `i`) и серия возможных значений (`case`).
Значение выражения по очереди сравнивается с выражениями, следующими после ключевого слова `case`.
Если они оказываются равны, то выполняется действие, описанное после `:`.

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение, которое сошлось с выражением.
Переключатель также поддерживает действие по умолчанию, которое будет выполнено в случае, если не подошло ни одно из возможных значений (напоминает `else` в операторе `if`).

В `switch` можно использовать любой тип данных.

#### Стоит дополнить, что:
1.  В Go код после case выполняется до следующего case, и нет нужды каждый `case`-блок заканчивать ключевым словом **break** (данная особенность добавлена в язык специально, чтобы уменьшить количество ошибок в switch-блоках).
 
    Если в текущем case написать `fallthrough`, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего `case`) условие:
    ```go
    v := 42
    switch v {
    case 100:
        fmt.Println(100)
        fallthrough
    case 42:
        fmt.Println(42)
        fallthrough
    case 1:
        fmt.Println(1)
        fallthrough
    default:
        fmt.Println("default")
    }
    // Вывод:
    // 42
    // 1
    // default
    ```
2.  Существует специальная форма `switch`, допускающая использование произвольных условий в каждом `case`-блоке:
    ```go
    var c uint32
    fmt.Scan(&c)
    switch {
    case 1 <= c && c <= 9:
        fmt.Println("от 1 до 9")
    case 100 <= c && c <= 250:
        fmt.Println("от 100 до 250")
    case 1000 <= c && c <= 6000:
        fmt.Println("от 1000 до 6000")
    }
    ```
    
    То есть, сразу после switch "переключатель" не нужен, а после каждого `case` идет выражение с произвольным условием.

## Задания блока "1.9 Условные конструкции"
<details><summary>Раскрыть</summary>

### Step 5
На ввод подается целое число.
Если число положительное - вывести сообщение "Число положительное", если число отрицательное - "Число отрицательное".
Если подается ноль - вывести сообщение "Ноль". Выводить сообщение без кавычек.

**Sample Input**: 5

**Sample Output**: Число положительное

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  if iData > 0 {
    fmt.Println("Число положительное")
  } else if iData < 0 {
    fmt.Println("Число отрицательное")
  } else {
    fmt.Println("Ноль")
  }
}
```

### Step 6
По данному трехзначному числу определите, все ли его цифры различны.

**Формат входных данных**

На вход подается одно натуральное трехзначное число.

**Формат выходных данных**

Выведите "YES", если все цифры числа различны, в противном случае - "NO".

**Sample Input 1**: 237

**Sample Output 1**: YES

**Sample Input 2**: 117

**Sample Output 2**: NO

```go
package main

import "fmt"

func main() {
  var i1, i2, i3, iData int
  fmt.Scan(&iData)
  
  i1 = iData / 100
  i2 = (iData % 100) / 10
  i3 = iData % 10
  
  if i1 != i2 && i1 != i3 && i2 != i3 {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

### Step 7
Дано неотрицательное целое число. Найдите и выведите первую цифру числа. 

**Формат входных данных**

На вход дается натуральное число, не превосходящее 10000.

**Формат выходных данных**

Выведите одно целое число - первую цифру заданного числа.

**Sample Input**: 1234

**Sample Output**: 1

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  
  switch {
  case iData < 10:
    fmt.Println(iData)
  case iData >= 10 && iData < 100:
    fmt.Println(iData / 10)
  case iData >= 100 && iData < 1000:
    fmt.Println(iData / 100)
  case iData >= 1000 && iData < 10000:
    fmt.Println(iData / 1000)
  default:
    fmt.Println(1)
  }
}
```

### Step 8
Определите является ли билет счастливым. Счастливым считается билет, в шестизначном номере которого сумма первых трёх цифр совпадает с суммой трёх последних.

**Формат входных данных**

На вход подается номер билета - одно шестизначное  число.

**Формат выходных данных**

Выведите "YES", если билет счастливый, в противном случае - "NO".

**Sample Input**: 613244

**Sample Output**: YES

```go
package main

import "fmt"

func main() {
  var iData int
  var numb [6]int  
  fmt.Scan(&iData)
  
  numb[0] = iData / 100000
  numb[1] = (iData % 100000) / 10000
  numb[2] = (iData % 10000) / 1000
  numb[3] = (iData % 1000) / 100
  numb[4] = (iData % 100) / 10
  numb[5] = iData % 10
  
  if numb[0] + numb[1] + numb[2] == numb[3] + numb[4] + numb[5] {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

### Step 9
Требуется определить, является ли данный год високосным, напомним:

Год является високосным если он соответствует хотя бы одному из нижеперечисленных условий:
- кратен 400;
- кратен 4, но не кратен 100.

**Входные данные**

Вводится единственное число - номер года (целое, положительное, не превышает 10000).

**Выходные данные**

Требуется вывести слово YES, если год является високосным и NO - в противном случае.

**Sample Input**: 2000

**Sample Output**: YES

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  
  if iData % 400 == 0 {
    fmt.Println("YES")
  } else if iData % 4 == 0 && iData % 100 != 0 {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

</details>


## Циклы в Go
Единственной конструкцией для циклов в Go является оператор `for`.

Его базовая форма выглядит следующим образом:
```
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
```

Пример использования:
```go
package main

import "fmt"

func main() {
	sum := 0
	for i := 1; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

Объявление цикла `for` разбивается на три части.
Вначале идет инициализация счетчика: `i := 1`.
Фактически она представляет объявление переменной, которая будет использоваться внутри цикла.
В данном случае это счетчик `i`, начальное значение которого равно 1.

Вторая часть представляет условие: `i < 10`.
Пока это условие истинно, то есть возвращает `true`, будет продолжаться цикл.

Третья часть представляет изменение (увеличение) счетчика на единицу.

Нам необязательно указывать все условия при объявлении цикла.
Например, можно вынести объявление переменной вовне:
```go
var i = 1
for ; i < 10; i++{
    fmt.Println(i * i)
}
```

Можно убрать изменение счетчика в само тело цикла и оставить только условие:
```go
var i = 1
for ; i < 10;{
    fmt.Println(i * i)
    i++
}
```

Если цикл использует только условие, то его можно сократить следующим образом:
```go
var i = 1
for i < 10{
    fmt.Println(i * i)
    i++
}
```

При этом в последнем случае мы получим по сути аналог цикла `while` в других языках программирования.

Так же можно реализовать бесконечный цикл:
```go
for {

}
```

**Кстати**, иногда удобно пользоваться такой конструкцией ввода данных:

(но будьте осторожны, ведь мы не обрабатываем здесь ошибки)
```go
var n int
// считываем числа пока не будет введен 0
for fmt.Scan(&n); n != 0; fmt.Scan(&n){
	fmt.Println(n)
}
```

## Задания 2-5
<details><summary>Раскрыть</summary>

### Задание 2
Напишите программу, которая выводит квадраты натуральных чисел от 1 до 10.
Квадрат каждого числа должен выводится в новой строке.
```go
package main

import "fmt"

func main() {
    for i := 1; i <= 10; i++ {
        fmt.Println(i * i)   
    }
}
```

### Задание 3
Требуется написать программу, при выполнении которой с клавиатуры считываются два натуральных числа A и B (каждое не более 100, A < B).
Вывести сумму всех чисел от A до B включительно.

**Sample Input**: 1 5
**Sample Output**: 15

```go
package main

import "fmt"

func main() {
    var A, B, out int
    
    fmt.Scan(&A, &B)
    
    for i := A; i <= B; i++ {
        out = out + i
    }
    
    fmt.Println(out)
}
```

### Задание 4
Напишите программу, которая в последовательности чисел находит сумму двузначных чисел, кратных 8.
Программа в первой строке получает на вход число n - количество чисел в последовательности, во второй строке -- n чисел, входящих в данную последовательность.

**Sample Input**:

5

38 24 800 8 16

**Sample Output**: 40

```go
package main

import "fmt"

func main() {
    var n, iData, out int
    
    fmt.Scan(&n)
    
    for i := 0; i < n; i++ {
        fmt.Scan(&iData)
        if iData >= 10 && iData < 100 && iData % 8 == 0 {
            out = out + iData
        }
    }
    
    fmt.Println(out)
}
```

### Step 5
Последовательность состоит из натуральных чисел и завершается числом 0.
Определите количество элементов этой последовательности, которые равны ее наибольшему элементу.

**Формат входных данных**

Вводится непустая последовательность натуральных чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).

**Формат выходных данных**

Выведите ответ на задачу.

**Sample Input**:

1

3

3

1

0

**Sample Output**: 2

```go
package main

import "fmt"

func main() {
    var iData, iMax, oData int
    
    for fmt.Scan(&iData); iData != 0; fmt.Scan(&iData){
        if iData > iMax {
            iMax = iData
            oData = 1
        } else if iData == iMax {
            oData++
        }
    }
    
    fmt.Println(oData)
}
```

</details>


### Операторы break и continue
Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а сразу перейти к следующей итерации.
В этом случае можно использовать оператор `continue`.
Например, нам нужно в диапазоне от 1 до 10 посчитать сумму нечетных чисел.
Если нам встретится четное число, мы можем просто перейти к следующей итерации с помощью `continue`:
```go
var sum = 0
 
for i := 1; i <= 10; i++{
    if i % 2 == 0 {
        continue        // переходим к следующей итерации
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 25
```

Оператор `break` полностью осуществляет выход из цикла:
```go
var sum = 0
 
for i := 1; i <= 9; i++{
    if i > 4 {
        break       // если число больше 4 выходим из цикла
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 10
```

## Задания 7-10
<details><summary>Раскрыть</summary>

### Step 7
Найдите первое число от 1 до n включительно, кратное c, но НЕ кратное d.

**Входные данные**

Вводится 3 натуральных числа n, c, d, каждое из которых не превышает 10000.

**Выходные данные**

Вывести первое число от 1 до n включительно, кратное c, но НЕ кратное d. Если такого числа нет - выводить ничего не нужно.

**Sample Input**: 20 3 5
**Sample Output**: 3

```go
package main

import "fmt"

func main() {
    var n, c, d int
    fmt.Scan(&n, &c, &d)
    
    for i := 1; i <= n; i++ {
        if (i % c == 0) && (i % d != 0) {
            fmt.Println(i)
            break
        }
    }
}
```

### Step 8
Напишите программу, которая считывает целые числа с консоли по одному числу в строке.

Для каждого введённого числа проверить:
* если число меньше 10, то пропускаем это число;
* если число больше 100, то прекращаем считывать числа;
* в остальных случаях вывести это число обратно на консоль в отдельной строке.
---
**Sample Input**:

30

11

7

101

---
**Sample Output**:

30

11

---
```go
package main

import "fmt"

func main() {
    var iData int
    
    for fmt.Scan(&iData); iData <= 100; fmt.Scan(&iData) {
        if iData >= 10 {
            fmt.Println(iData)
        }
    }
}
```

### Step 9
Вклад в банке составляет x рублей.
Ежегодно он увеличивается на p процентов, после чего дробная часть копеек отбрасывается.
Каждый год сумма вклада становится больше.
Определите, через сколько лет вклад составит не менее y рублей.

**Входные данные**

Программа получает на вход три натуральных числа: x, p, y.

**Выходные данные**

Программа должна вывести одно целое число.

---
**Sample Input**: 100 10 200

---
**Sample Output**: 8

---
```go
package main

import "fmt"

func main() {
    var x, y, oData int
    var p float32
    
    fmt.Scan(&x, &p, &y)
    p = p / 100 + 1
    
    for {
        x = int(float32(x) * p)
        oData++
        if x >= y {
            fmt.Println(oData)
            break
        }
    }
}
```

### Step 10
Даны два числа.
Определить цифры, входящие в запись как первого, так и второго числа.

**Входные данные**

Программа получает на вход два числа.
Гарантируется, что цифры в числах не повторяются.
Числа в пределах от 0 до 10000.

**Выходные данные**

Программа должна вывести цифры, которые имеются в обоих числах, через пробел.
Цифры выводятся в порядке их нахождения в первом числе.

---
**Sample Input**: 564 8954

---
**Sample Output**: 5 4

---
```go
package main

import "fmt"

func main() {
    var iData1, iData2 string
    
    fmt.Scan(&iData1, &iData2)
    
    for i := 0; i < len(iData1); i++ {
        for k := 0; k < len(iData2); k++ {
            if iData1[i] == iData2[k] {
                fmt.Print(string(iData1[i]), " ")
            }
        }
    }
}
```

</details>


## Форматированный вывод
`fmt.Printf()` на вход принимает сначала строку форматирования, а только потом переменные для вывода.
Строка форматирования представляет набор спецификаторов.
Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются знаком процента `%`.

Каждый спецификатор представляет определенный тип данных:
* `%t`: для вывода значений типа boolean (true или false)
* `%b`: для вывода целых чисел в двоичной системе
* `%c`: для вывода символов, представленных числовым кодом
* `%d`: для вывода целых чисел в десятичной системе
* `%o`: для вывода целых чисел в восьмеричной системе
* `%q`: для вывода символов в одинарных кавычках
* `%x`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
* `%X`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
* `%U`: для вывода символов в формате кодов Unicode, например, U+1234
* `%e`: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
* `%E`: тоже самое что `%e` но в верхнем регистре, например, -1.234456E+78
* `%f`: для вывода чисел с плавающей точкой, например, 123.456
* `%F`: то же самое, что и `%f`
* `%g`: `%e` для огромных экспонент, `%f` в противном случае
* `%G`: `%E` для огромных экспонент, `%F` в противном случае
* `%s`: для вывода строки
* `%p`: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
* `%T` для вывода типа переменной

Также можно применять универсальный спецификатор `%v`, который для типа boolean аналогичен `%t`, для целочисленных типов - `%d`, для чисел с плавающей точкой - `%g`, для строк - `%s`.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части.
Для этого количество символов указывается после точки: `%.2f` - две цифры в дробной части после точки.

Например, варианты форматирования чисел с плавающей точкой:
* `%f`: точность и ширина значения по умолчанию
* `%9f`: ширина - 9 символов и точность по умолчанию (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)
* `%.2f`: ширина по умолчанию и точность - 2 символа
* `%9.2f`: ширина - 9 и точность - 2
* `%9.f`: ширина - 9 и точность - 0

Примеры:
```go
var a float64 = 100.123456
fmt.Printf("это число %f типа %T", a, a)
// вывод: это число 100.123456 типа float64

var a1 byte = 's'
var a2 int = 1234
fmt.Printf("%q %b", a1, a2)
// вывод: 's' 10011010010


// использование \n позволяет сделать перенос строки
var a1 string = "123"
var a2 string = "1234"
fmt.Printf("%q \n%s", a1, a2)
// вывод: 
// "123" 
// 1234
```


### Sprintf
Также есть функция `Sprintf()` которая работает как и `Printf()`, за исключением того что она ничего не печатает, а возвращает результат форматирования, рассмотрим пример:

```go
package main

import (
	"fmt"
)

func main() {
	var a float64 = 100.123456789
	result := fmt.Sprintf("%.2f", a)
	fmt.Printf("%q", result) // вывод: "100.12"
        // result будет типа string
}
```

### Литералы строк
Вначале определим разницу между литералами строк и значениями строк.
Литерал строк — это то, что мы видим в исходном коде компьютерной программы, включая кавычки.
Значение строки — это то, что мы видим в окне терминала когда вызываем функцию `fmt.Println` после запуска программы Go.

В простой программе `Hello, World!` литерал строки будет выглядеть как `"Hello, World!"`, а значением строки будет `Hello, World!` без кавычек.

Однако для некоторых значений строк могут требоваться кавычки, в частности в случае с цитатами.
Поскольку литералы строк и значения строк не эквивалентны, часто требуется добавлять в литералы строк дополнительное форматирование, чтобы значения строк отображались ожидаемым образом.

### Кавычки и обратный апостроф
В Go можно использовать обратный апостроф (``) или двойные кавычки ("), поэтому мы можем легко вставлять цитаты в строку, выделяя их двойными кавычками, в то время как сама строка выделена обратными апострофами:
```
`Sammy says, "Hello!"`
```

Также вы можете использовать обратные апострофы и заключить строку в двойные кавычки:
```
"Sammy likes the `fmt` package for formatting strings.."
```

Кроме того, комбинирование обратных апострофов и двойных кавычек позволяет контролировать отображение символов кавычек и одинарных кавычек в строках.

Важно помнить, что при использовании обратных апострофов в Go создается чистый литерал строки, а при использовании двойных кавычек — интерпретированный литерал строки.
Чтобы узнать больше о разнице между ними, ознакомьтесь с руководством [Введение в работу со строками в Go](https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go).

### Управляющие символы
Также для форматирования строк используются **управляющие символы**.
Управляющие символы интерпретируются кодом как имеющие особое значение.
Управляющие символы начинаются с обратной косой черты (\), за которой идет другой символ строки, в результате чего строка имеет определенный формат.

Далее приведен перечень нескольких распространенных управляющих символов, а также примеры экранирования:

| Оператор | 	Формат                                                                    | 	Пример кода       | 	Результат 
|----------|----------------------------------------------------------------------------|--------------------|------------|
| \\\\     | Обратная косая черта (это пример экранирования, а не управляющего символа) | fmt.Printf("\\\\") | \          |
| \\"      | Двойные кавычки (это пример экранирования, а не управляющего символа)      | fmt.Printf("\\"") | "          |
| \f       | подача страницы                                                            | fmt.Printf("123\f456\f789") |            |
| \v       | вертикальный таб                                                           | fmt.Printf("\vf\v") |            |
| \r | возврат каретки                                                            | fmt.Printf("\r Input ") fmt.Scan(&a) |            |
| \b | возврат (backspace U+0008)                                                 | fmt.Printf("123\b") fmt.Scan(&a) |            |
| \t | Табуляция (горизонтальный отступ)                                          | fmt.Printf("\ttest") | |
| \n | Перевод строки                                                             | fmt.Printf("test\ntest") | |

Так же есть `\a` - особый управляющий символ, необходимый для создания звука (alert).

### Многострочная печать
Многострочная печать строк делает текст более удобным для чтения.
Размещение строк в нескольких рядах делает текст более понятным и упорядоченным, позволяет форматировать его как письмо или сохранить разрывы строк в стихотворении или тексте песни.

Для создания строк, отображаемых на нескольких рядах, их нужно заключить в обратные апострофы.
Помните, что хотя при этом сохраняются символы возврата строки, создаваться будут чистые литералы строки.
```
`
This string is on
multiple lines
within three single
quotes on either side.
`
```

Если вы распечатаете этот текст, вы увидите, что символ возврата имеется в начале и в конце строки:
```
This string is on
multiple lines
within three single
quotes on either side.
```

Во избежание этого следует поместить первый ряд сразу же за обратным апострофом и закончить последний ряд обратным апострофом.
```
`This string is on
multiple lines
within three single
quotes on either side.`
```

Если вам нужно создать интерпретированный литерал строки, вы можете использовать двойные кавычки и оператор `+`, но при этом вам нужно будет самостоятельно вставлять символы разрыва строки между рядами.
```
"This string is on\n" +
"multiple lines\n" +
"within three single\n" +
"quotes on either side."
```

Хотя с обратными апострофами намного проще распечатывать и читать длинный текст, если вам требуется интерпретированный литерал строки, вам нужно использовать двойные кавычки.

### Чистые литералы строк
Что, если нам не нужно особое форматирование строк?
Например, нам может понадобиться сравнить или оценить несколько строк программного кода, где целенаправленно используется символ обратного слеша, так что мы не хотим, чтобы Go использовал этот символ как управляющий или как элемент экранирования.

Чистый литерал строки указывает Go игнорировать все форматирование строки, включая управляющие символы.

Мы можем создать чистую строку, заключив строку в обратные апострофы:
```
fmt.Println(`Sammy says,\"The balloon\'s color is red.\"`)
```
```
Sammy says,\"The balloon\'s color is red.\"
```

Построение чистой строки с помощью обратных апострофов вокруг нее позволяет сохранить в тексте символы обратного слеша и другие символы, которые используются в качестве управляющих символов.


## Массивы и срезы
### Понятие массива. Объявление и инициализация массива
**Массив** — это последовательность элементов одного типа фиксированной длины.
Объявление массива осуществляется следующим образом:
```go
var a [3]int
fmt.Println(a) // [0 0 0]
```

При объявлении массива в квадратных скобках указывается его длина (length), которая совместно с типом элементов, определяет тип самого массива, т.е. `[3]int` не может просто так взаимодействовать с `[5]int` (массивы разной длины относятся к разным типам независимо от того, что хранят значения одного типа), также как не могут без приведения взаимодействовать `int64` и `int32`.

Как мы увидели в приведенном примере, объявленный массив был при объявлении инициализирован нулевыми значениями (0 для int).
Такое поведение не является стандартным, в частности в языках C / C++ объявленный массив нулевыми значениями не заполняется.

Одновременно с объявлением массива мы можем задать значения его элементов (инициализировать его):
```go
var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]
```

В понимании первого и второго примера сложности возникнуть не должно - с этим вы уже сталкивались.
Остановимся чуть подробнее на вариантах три и четыре (массивы c и d).

Вместо явного указания длины массива мы можем указать символ многоточия (`...`) в квадратных скобках, тогда длина массива будет определена Go в зависимости от количества указанных при инициализации значений.
Несмотря на то, что такой вариант допустим, он не считается идиоматичным для Go и не рекомендуется к использованию в документации.

Четвертый же способ инициализации позволяет явно указать значение, которое должно быть присвоено элементу массива с определенным индексом.
В этом случае индексы могут появляться в любом порядке, а некоторые из них могут быть опущены; как и прежде, неуказанные значения получают нулевое значение типа элемента.

### Сравнение массивов
Поскольку мы можем последовательно сравнить все элементы массива, мы можем сравнить и сами массивы:
```go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false
```

Но при этом нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).

### Обращение к элементам массива. Индексы
Для обращения к элементам массива применяются индексы - номера элементов.
При этом нумерация элементов массива начинается с нуля, то есть первый элемент будет иметь индекс 0.
Индекс указывается в квадратных скобках.
По индексу можно получить значение элемента, либо изменить его:
```go
package main

import "fmt"

func main() {   
    var numbers [5]int = [5]int{1,2,3,4,5}    

    fmt.Println(numbers[0])     // 1  
    fmt.Println(numbers[4])     // 5   

    numbers[0] = 87   

    fmt.Println(numbers[0])     // 87
}
```

Однако в большинстве случаев нам необходимо обратиться ко всем элементам массива и выполнить с ними определенную работу.
Мы можем сделать это с помощью цикла:
```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for i := 0; i < len(a); i++ {
	fmt.Println(a[i])
	// 1
	// 2
	// 3
	// 4
	// 5
}
```

Обратите внимание, что определяя условие продолжения выполнения цикла мы использовали встроенную функцию `len()`, возвращающую длину массива.
Поскольку индексация элементов массива начинается с 0, то последний элемент массива a будет иметь индекс `len(a) - 1`.

При итерации по массиву мы можем использовать ключевое слово range, тогда цикл будет иметь следующий вид:
```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}
```

`Range` возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента.
Любой из этих объектов должен быть опущен, если мы не планируем использовать его, для этого вместо имени переменной мы можем указать символ `_`.
Кроме того, если мы хотим использовать только индекс элемента, мы можем вообще не использовать второе возвращаемое значение:
```go
a := [5]int{1, 2, 3, 4, 5}

for idx := range a {
    fmt.Println(a[idx])
}

for idx, _ := range a {
    // В этом случае следует использовать приведенный выше вариант,
    // хотя технически эти варианты работают одинаково
    fmt.Println(a[idx])
}

for _, elem := range a {
    fmt.Println(elem)
}
```

Необходимо запомнить, что в качестве второго значения `range` возвращает копию элемента массива, это может быть важно, если в цикле мы хотим изменить массив.
В этом случае мы должны обращаться к элементам массива по индексу:
```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for _, elem := range a {
    elem = 100
    fmt.Println(elem)

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [1 2 3 4 5]

for idx := range a {
    a[idx] = 100
    fmt.Println(a[idx])

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [100 100 100 100 100]
```

### Задание 5

<details><summary>Раскрыть</summary>
Внутри функции main (объявлять функцию не нужно) необходимо написать программу:

На первом этапе на стандартный ввод подается 10 целых положительных чисел, которые должны быть записаны в порядке ввода в массив из 10 элементов.
Тип чисел, входящих в массив, должен соответствовать минимально возможному целому беззнаковому числу.
Имя массива который вы должны сами создать workArray (условие обязательное).
Для чтения из стандартного ввода уже импортирован пакет fmt.

На втором этапе на стандартный ввод подаются еще 3 пары чисел - индексы элементов этого массива, которые требуется поменять местами (если такая пара чисел 3 и 7, значит в массиве элемент с 3 индексом нужно поменять местами с элементом, индекс которого 7).

Элементы полученного массива должны быть выведены через пробел на стандартный вывод.
Далее автоматически будет проведена проверка используемых типов, результат которой будет добавлен к вашему ответу.

Использование массива - обязательное условие!

Ответ:
```go
var workArray [10]uint8
var switchArray [6]uint8

for i := 0; i < 10; i++ {
    fmt.Scan(&workArray[i])
}
for i := 0; i < 6; i++ {
    fmt.Scan(&switchArray[i])
}

for i := 0; i < 6; i = i + 2 {
    workArray[switchArray[i]], workArray[switchArray[i+1]] = workArray[switchArray[i+1]], workArray[switchArray[i]]
}
for i := range workArray {
    fmt.Print(workArray[i], " ")
}
```

</details>


## Срезы (слайсы, slices)
**Срез** — это последовательность элементов одного типа переменной длины.

Массивы и срезы тесно связаны.
Срез — это структура данных, которая предоставляет доступ к подпоследовательности элементов базового массива.
Длину массива изменять нельзя, а вот новые элементы в срез добавлять можно, так что в некоторых языках срезами называются динамические массивы.

Срез состоит из трех компонентов: указателя, длины и емкости:
* указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
* длина (length) — это количество элементов среза;
* емкость (capacity) - количество элементов между началом среза и концом базового массива.

Длина и емкость среза могут быть определены при помощи встроенных функций `len()` и `cap()` соответственно.

## С оздание среза
### Создание пустого среза
Пустой срез может быть создан аналогично созданию массива за тем исключением, что нам нет необходимости указывать длину среза, поскольку она изменяема.
При создании пустого среза мы также можем инициализировать его, явно указав элементы среза.
Давайте рассмотрим, чем различается создание массива и среза:
```go
var a []int
var b []int = []int{1, 2, 3}
c := []int{1, 2, 3}
d := []int{1: 12}

fmt.Println(a) // []
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12]
```

Варианты b и c идентичны тем, что мы уже видели при создании массива (вы можете вернуться к ранее приведенным примерам и удостовериться в этом).

В том случае, если мы просто объявляем пустой срез, он не содержит элементов (его длина равна 0, в чем мы можем удостовериться, воспользовавшись функцией `len`) - в аналогичном случае длина массива явно задается при его объявлении.

Вариант d позволяет нам создать срез и явно указать значения элементов по его индексу, Go инициализирует нужное для выполнения этой задачи число элементов нулевым значением: в примере элемент с индексом 0 равен 0, хотя мы не объявляли его явно.

На этом способы создания среза в Go не заканчиваются.
Для гибкого способа создания пустых срезов в Go существует встроенная функция make следующего вида:
```go
make([]T, length, capacity)
```

Чтобы разобраться с этой функцией нам нужно посмотреть, что происходит при создании пустого среза: Go создает массив какой-то длины.
О понятии среза мы говорили выше: указатель среза будет указывать на первый элемент созданного массива, длина среза составит 0 (если мы явно не указали элементы среза), емкость необходимого массива будет определена Go самостоятельно.

Для чего нам может потребоваться явно указать длину и емкость среза:

* для того, чтобы инициализировать нулевыми значениями элементы массива (длина среза);
* для того, чтобы выделить нужное количество памяти для хранения массива, лежащего в основе нашего среза.

```go
a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0]
fmt.Println(a)
```

Функция `make` широко применяется на практике, в дальнейшем вы не раз будете использовать ее.


## Оператор среза
Оператор среза `s[i:j]` создает из последовательности s новый срез, который содержит элементы последовательности `s` с `i` по `j-1`.
При этом должно соблюдаться условие `0 <= i <= j <= cap(s)`.
В качестве исходной последовательности, из которой берутся элементы, может использоваться массив, указатель на массив или другой срез.
В итоге в полученном срезе будет `j-i` элементов.

Если значение `i` не указано, то применяется по умолчанию значение 0.
Если значение `j` не указано, то вместо него используется длина исходной последовательности `s`.
```go
initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"} // базовый массив

users1 := initialUsers[2:6] // с 3-го по 6-й
users2 := initialUsers[:4] // с 1-го по 4-й
users3 := initialUsers[3:] // с 4-го до конца

fmt.Println(users1) // [Kate Sam Tom Paul]
fmt.Println(users2) // [Bob Alice Kate Sam]
fmt.Println(users3) // [Sam Tom Paul Mike Robert]
```

## Встроенные функции для работы со срезами
Для работы со срезами в Go предусмотрены встроенные функции `append` и `copy`.

### Функция append - добавление элементов в срез
Функция `append` позволяет добавить в срез новый элемент, выглядит она следующим образом:
```go
func append(slice []Type, elems ...Type) []Type
```

В качестве первого аргумента функция получает срез, в который необходимо добавить новые элементы, второй и последующий элементы - это элементы совместимого со срезом типа, которые необходимо добавить в срез.
Функция возвращает новый срез, содержащий ранее содержавшиеся в срезе элементы, а также новые элементы, переданные в качестве аргумента функции append.
Подробно функции будут рассмотрены в разделе 2.1. Функции.
```go
a := []int{1, 2, 3}
a = append(a, 4, 5)

fmt.Println(a) // [1 2 3 4 5]
```

### Немного сложного
Теперь самое время вернуться к вопросу о длине и емкости среза, чтобы в контексте работы функции append рассмотреть внутренне устройство срезов.
Что произойдет, если добавить в срез длины N и такой же емкости элементов больше N?
Посмотрим на примере:
```go
baseArray := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
fmt.Printf("Базовый массив: %v\n", baseArray)

baseSlice := baseArray[5:8]
fmt.Printf(
    "Срез, основанный на базовом массиве длиной %d и емкостью %d: %v\n",
    len(baseSlice),
    cap(baseSlice),
    baseSlice,
)

// Output:
// Базовый массив: [0 1 2 3 4 5 6 7 8 9]
// Срез, основанный на базовом массиве длиной 3 и емкостью 5: [5 6 7]
```

И так, мы создали массив из 10 элементов типа int, а затем создали срез на его элементы 5-7 (значения элементов в примере соответствуют их индексам).
Таким образом длина среза составляет 3, а емкость 5 (если вы не понимаете, почему получилось именно так, посмотрите еще раз в шестом шаге этого урока, из каких компонентов состоит срез).

Теперь проведем небольшую подготовительную работу.
Мы знаем, что один из компонентов среза: указатель на элемент массива, который является первым элементом среза.
Сохраним этот указатель в переменной pointer в виде строки (мы не будем его печатать, т.к. во время каждого исполнения программы он будет разным, но мы сможем использовать сохраненное значение для сравнения):
```go
pointer := fmt.Sprintf("%p", baseSlice)
```

_Напоминание_: Конструкция %p говорит, что в качестве результата должен быть возвращен адрес элемента массива, на который ссылается baseSlice.

Теперь добавим новый элемент в наш срез и посмотрим, как это повлияет на наш базовый массив:
```go
baseSlice = append(baseSlice, 10)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 4 и емкостью 5: [5 6 7 10]
// true
```

Мы видим, что изменился не только наш срез, но и базовый массив, на который ссылается срез.
Длина среза изменилась автоматически.
А теперь повторим предыдущую операцию, но добавим столько элементов, чтобы емкости среза не хватило:
```go
baseSlice = append(baseSlice, 11, 12, 13)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 7 и емкостью 10: [5 6 7 10 11 12 13]
// false
```

Мы видим, что базовый массив не изменился, а наш срез теперь ссылается на другой массив и имеет емкость больше длины.
Почему так произошло?
При добавлении элементов в срез Go проверяет, достаточно ли емкости среза для добавления новых элементов в срез (т.е. есть ли еще место в массиве, на котором основан срез).
Если емкости не достаточно, то создается новый срез, основанный на массиве большего объема, в который копируются все элементы из старого среза, а также добавляются новые элементы.

Этот пример наглядно демонстрирует как устроены срезы в Go: создав один раз срез на основе массива достаточной нам длины, мы можем избежать операций выделения памяти при создании нового массива и копирования элементов из одного массива в другой.

### Использование append для удаления элемента из среза
В Go отсутствует встроенная функция для удаления элемента из среза, но мы можем воспользоваться функцией append для того, чтобы создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:
```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

В этом примере встречается символ `...` после указания на передачу среза в качестве аргумента.
В настоящий момент можете запомнить, что такое использование многоточия означает раскрытие среза (его элементы передаются функции append как отдельные аргументы).

### Функция copy - копирование элементов среза
Сразу рассмотрим описание функции:
```go
func copy(dst, src []Type) int
// про функции мы поговорим в 2 модуле, ничего страшного если вам не очень понятно ;)
```

`Copy` принимает срез-назначение и срез источник, а возвращает число скопированных элементов:
```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```

Почему мы явно указали длину создаваемого среза b?
Потому что иначе функции было бы некуда копировать.
Имей срез b длину 1, был бы скопирован 1 элемент из среза a.


## Особенности работы со срезами
Методики работы со срезами аналогичны работе с массивами с учетом тех особенностей, которые мы рассмотрели ранее.
Последовательность элементов среза также можно обойти с использованием цикла, обращаясь к ним с использованием индекса или получая значение с использованием range.

Однако существует особенность, которую ранее мы не рассматривали напрямую, поскольку сама проблема выходит за рамки рассматриваемой темы.

Рассматривая эти темы помните о том, что срез по своей сути - указатель на массив, а это влияет на его поведение при передаче в качестве аргумента в функцию:
```go
func fnA(a [3]int) {
	a[1] = 15
}

func fnB(a []int) {
	a[1] = 15
}

func main() {
	a := [3]int{1, 2, 3}
	b := []int{1, 2, 3}

	fnA(a)
	fnB(b)

	fmt.Println(a) // [1 2 3]
	fmt.Println(b) // [1 15 3]
}
```

В приведенном примере мы создали 2 функции: fnA и fnB.
Первая получает в качестве аргумента массив из 3-х элементов, вторая - срез.
Обе функции изменяют второй элемент последовательности, но мы получаем совсем разный результат, потому что fnB работала с указателем на массив и изменила непосредственно сам массив, fnA же работала с копией массива, поэтому внутри функции был изменен элемент копии массива, а базовый массив остался неизменен.

### Задания
<details><summary>Раскрыть</summary>

#### Step 14
На ввод подаются пять целых чисел, которые записываются в массив. Однако эта часть программы уже написана.
Вам нужно написать фрагмент кода, с помощью которого можно найти и вывести максимальное число в этом массиве.
```go
package main
import "fmt"

func main()  {
	array := [5]int{}
	var a int
	for i:=0; i < 5; i++{
		fmt.Scan(&a)
		array[i] = a
	}
 
 for _, v := range array {
  if v > a {
   a = v
  }
 }
 
 fmt.Println(a)
}
```

#### Step 15
Дан массив, состоящий из целых чисел. Нумерация элементов начинается с 0. Напишите программу, которая выведет элементы массива, индексы которых четны (0, 2, 4...).

**Входные данные**

Сначала задано число NN — количество элементов в массиве (1 \leq N \leq 1001≤N≤100). Далее через пробел записаны NN чисел — элементы массива. Массив состоит из целых чисел.

**Выходные данные**

Необходимо вывести все элементы массива с чётными индексами.
```go
package main
import "fmt"

func main() {
  var nElem int
  fmt.Scan(&nElem)
  nSlice := make([]int, nElem, nElem)
  
  for i := 0; i < nElem; i++ {
    fmt.Scan(&nSlice[i])
  }
  
  for i := 0; i < nElem; i=i+2 {
    fmt.Print(nSlice[i], " ")
  }
}
```

#### Step 16
Дана последовательность, состоящая из целых чисел. Напишите программу, которая подсчитывает количество положительных чисел среди элементов последовательности.

**Входные данные**

Сначала задано число NN — количество элементов в последовательности (1\leq N\leq1001≤N≤100). Далее через пробел записаны NN чисел — элементы последовательности. Последовательность состоит из целых чисел.

**Выходные данные**

Необходимо вывести единственное число - количество положительных элементов в последовательности.
```go
package main

import "fmt"

func main() {
	var iN, oN int
	fmt.Scan(&iN)
	iSlice := make([]int, iN, iN)

	for i := 0; i < iN; i++ {
		fmt.Scan(&iSlice[i])
		if iSlice[i] > 0 {
			oN++
		}
	}
	fmt.Println(oN)
}
```

</details>

## 1.13 Решение задач
<details><summary>Раскрыть</summary>

### Step 1
Дано трехзначное число. Найдите сумму его цифр. 

**Формат входных данных**
На вход дается трехзначное число.

**Формат выходных данных**
Выведите одно целое число - сумму цифр введенного числа.

```go
package main
import "fmt"

func main() {
	var iNum int
	var oSlice [3]int

	fmt.Scan(&iNum)

	oSlice[0] = iNum / 100
	oSlice[2] = iNum % 10
	oSlice[1] = (iNum - oSlice[0] * 100) / 10
	
	fmt.Print(oSlice[0] + oSlice[1] + oSlice[2])
}
```

### Step 2
Дано трехзначное число. Переверните его, а затем выведите. 

**Формат входных данных**
На вход дается трехзначное число, не оканчивающееся на ноль.

**Формат выходных данных**
Выведите перевернутое число.

```go
package main
import "fmt"

func main() {
	var iNum int
	var oSlice [3]int

	fmt.Scan(&iNum)

	oSlice[0] = iNum / 100
	oSlice[2] = iNum % 10
	oSlice[1] = (iNum - oSlice[0] * 100) / 10

	oSlice[0], oSlice[2] = oSlice[2], oSlice[0]
	
	fmt.Printf("%d%d%d", oSlice[0], oSlice[1], oSlice[2])
}
```

### Step 3
Идёт k-я секунда суток. Определите, сколько целых часов h и целых минут m прошло с начала суток. Например, если

k=13257=3*3600+40*60+57,

то h=3 и m=40.

**Входные данные**

На вход программе подается целое число k (0 < k < 86399).

**Выходные данные**

Выведите на экран фразу:

`It is ... hours ... minutes.`

Вместо многоточий программа должна выводить значения h и m, отделяя их от слов ровно одним пробелом.

```go
package main
import "fmt"

func main() {
	var iNum int
	var oSlice [2]int

	fmt.Scan(&iNum)

	oSlice[0] = iNum / 3600
	oSlice[1] = (iNum - oSlice[0] * 3600) / 60

	fmt.Printf("It is %d hours %d minutes.", oSlice[0], oSlice[1])
}
```

### Step 4
Заданы три числа - a, b, c (a < b < c)a,b,c(a<b<c) - длины сторон треугольника. Нужно проверить, является ли треугольник прямоугольным. Если является, вывести "Прямоугольный". Иначе вывести "Непрямоугольный"

**Sample Input:**

`6 8 10`

**Sample Output:**

`Прямоугольный`

```go
package main
import "fmt"

func main() {
	var iSlice [3]int
	var maxKey int

	for k := range iSlice {
		fmt.Scan(&iSlice[k])
		if iSlice[k] > iSlice[maxKey] {
			maxKey = k
		}
	}

	iSlice[0], iSlice[maxKey] = iSlice[maxKey], iSlice[0]
	if (iSlice[0] * iSlice[0] - iSlice[1] * iSlice[1] - iSlice[2] * iSlice[2]) == 0 {
		fmt.Println("Прямоугольный")
	} else {
		fmt.Println("Непрямоугольный")
	}
}
```

### Step 5
**Входные данные**

Даны три натуральных числа a, b, c.
Определите, существует ли треугольник с такими сторонами.

**Выходные данные**

Если треугольник существует, выведите строку "Существует", иначе выведите строку "Не существует".
Строку выводите без кавычек.

```go
package main
import "fmt"

func main() {
	var iSlice [3]int

	for k := range iSlice {
		fmt.Scan(&iSlice[k])
	}

	if (iSlice[0] + iSlice[1] > iSlice[2]) && (iSlice[0] + iSlice[2] > iSlice[1]) && (iSlice[1] + iSlice[2] > iSlice[0]) {
		fmt.Print("Существует")
	} else {
		fmt.Print("Не существует")
	}
}
```

### Step 6
Даны два числа.
Найти их среднее арифметическое.

**Формат входных данных**

На вход дается два целых положительных числа a и b.

**Формат выходных данных**

Программа должна вывести среднее арифметическое чисел a и b (ответ может быть целым числом или дробным)
```go
package main
import "fmt"

func main() {
	var iSlice [2]int

	for i := range iSlice {
		fmt.Scan(&iSlice[i])
	}

	fmt.Printf("%v", float64(iSlice[0] + iSlice[1]) / 2)
}
```

### Step 7
По данным числам, определите количество чисел, которые равны нулю.  

**Входные данные**

Вводится натуральное число N, а затем N чисел.

**Выходные данные**

Выведите количество чисел, которые равны нулю.
```go
package main
import "fmt"

func main() {
	var iN, oN, temp int

	fmt.Scan(&iN)

	for i := 0; i < iN; i++ {
		fmt.Scan(&temp)
		if temp == 0 {
			oN++
		}
	}

	fmt.Print(oN)
}
```

### Step 8
Найдите количество минимальных элементов в последовательности.

**Входные данные**

Вводится натуральное число N, а затем N целых чисел последовательности.

**Выходные данные**

Выведите количество минимальных элементов последовательности.
```go
package main
import "fmt"

func main() {
	var iN, oN, minN, temp int

	fmt.Scan(&iN)

	for i := 0; i < iN; i++ {
		fmt.Scan(&temp)
		if (temp < minN) || (i == 0) {
			minN = temp
			oN = 1
		} else if temp == minN {
			oN++
		}
	}

	fmt.Print(oN)
}
```

### Step 9
Цифровой корень натурального числа — это цифра, полученная в результате итеративного процесса суммирования цифр, на каждой итерации которого для подсчета суммы цифр берут результат, полученный на предыдущей итерации.
Этот процесс повторяется до тех пор, пока не будет получена одна цифра.

Например цифровой корень 65536 это 7 , потому что 6+5+5+3+6=25 и 2+5=7 . 

По данному числу определите его цифровой корень.

**Входные данные**

Вводится одно натуральное число n, не превышающее 10^7

**Выходные данные**

Вывести цифровой корень числа n.
```go
package main
import "fmt"

func main() {
	var iN, oN int
	var temp string

	fmt.Scan(&iN)
	temp = fmt.Sprint(iN)

	for ; len(temp) != 1; {
		oN = 0
		for _, v := range temp {
			oN = oN + int(v - '0')
		}
		temp = fmt.Sprint(oN)
	}

	fmt.Println(oN)
}
```

### Step 10
Самое большое число, кратное 7
Найдите самое большее число на отрезке от a до b, кратное 7 .

**Входные данные**

Вводится два целых числа a и b (a≤b).

**Выходные данные**

Найдите самое большее число на отрезке от a до b (отрезок включает в себя числа a и b), кратное 7 , или выведите "NO" - если таковых нет.
```go
package main
import "fmt"

func main() {
	var oN int
	var iArray [2]int
    var oSwitch bool

	for k := range iArray {
		fmt.Scan(&iArray[k])
	}
	
	for i := iArray[1]; i >= iArray[0]; i-- {
        if i % 7 == 0 {
			oN = i
            oSwitch = true
			break
		}
	}

	if !oSwitch {
		fmt.Println("NO")
	} else {
		fmt.Println(oN)
	}
}
```

### Step 11
По данному числу n закончите фразу "На лугу пасется..." одним из возможных продолжений: "n коров", "n корова", "n коровы", правильно склоняя слово "корова".

**Входные данные**

Дано число n (0<n<100).

**Выходные данные**

Программа должна вывести введенное число n и одно из слов (на латинице): korov, korova или korovy, например, 1 korova, 2 korovy, 5 korov.
Между числом и словом должен стоять ровно один пробел.
```go
package main
import "fmt"

func main() {
	var iN int

	fmt.Scan(&iN)

	switch {
	case iN / 10 == 1:
		fmt.Printf("%d korov", iN)
	case iN % 10 == 1:
		fmt.Printf("%d korova", iN)
	case (iN % 10 > 1) && (iN % 10 < 5):
		fmt.Printf("%d korovy", iN)
	default:
		fmt.Printf("%d korov", iN)
	}
}
```

### Step 12
По данному числу N распечатайте все целые значения степени двойки, не превосходящие N, в порядке возрастания.

**Входные данные**

Вводится натуральное число.

**Выходные данные**

Выведите ответ на задачу.
```go
package main

import (
	"fmt"
	"math"
)

func main() {
	var iN, oN, base int

	fmt.Scan(&iN)
	oN = 1
	base = 2

	for i := 1; oN <= iN; i++ {
		fmt.Print(oN, " ")
		oN = int(math.Pow(float64(base), float64(i)))
	}
}
```

### Step 13
Дано натуральное число A > 1.
Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число n, что φn=A.
Если А не является числом Фибоначчи, выведите число -1.

**Входные данные**

Вводится натуральное число.

**Выходные данные**

Выведите ответ на задачу.
```go
package main

import "fmt"

func main() {
	var iN int
	var iFibo [2]int = [2]int{1, 1}

	fmt.Scan(&iN)
	
	for i := 2; ; i++ {
		iFibo[0], iFibo[1] = iFibo[1], iFibo[0] + iFibo[1]

		if iN == iFibo[1] {
			fmt.Println(i+1)
			break
		} else if (iN > iFibo[0]) && (iN < iFibo[1]) {
			fmt.Println(-1)
			break
		}
	}
}
```

### Step 14
Дано натуральное число N. Выведите его представление в двоичном виде.

**Входные данные**


Задано единственное число N

**Выходные данные**

Необходимо вывести требуемое представление числа N.
```go
package main

import "fmt"

func main() {
	var iN int

	fmt.Scan(&iN)
	
	fmt.Printf("%b", iN)
}
```

### Step 15
Из натурального числа удалить заданную цифру.

**Входные данные**

Вводятся натуральное число и цифра, которую нужно удалить.

**Выходные данные**

Вывести число без заданных цифр.
```go
package main

import "fmt"

func main() {
	var iN, iDel, oStr string
	
	fmt.Scan(&iN)
	fmt.Scan(&iDel)

	for i := 0; i < len(iN); i++ {
		if string(iN[i]) != iDel {
			oStr += string(iN[i])
		}
	}
	
	fmt.Println(oStr)
}
```

</details>

