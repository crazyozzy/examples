# Основы
## Целые числа
В Go существуют следующие типы целых чисел: `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32` и `int64`.
8, 16, 32 и 64 говорит нам, сколько бит использует каждый тип.
`uint` означает «unsigned integer» (беззнаковое целое), в то время как `int` означает «signed integer» (знаковое целое).
Беззнаковое целое может принимать только положительные значения (или ноль).


| Тип     | Описание                               | Принимаемые значения |
|---------|----------------------------------------| --- |
| uint8   | Беззнаковые 8-битные целые числа       |    от 0 до 255
| uint16  | Беззнаковые 16-битные целые числа      |    от 0 до 65535
| uint32  | Беззнаковые 32-битные целые числа      |	от 0 до 4294967295
| uint64  | 	Беззнаковые 64-битные целые числа  | 	от 0 до 18446744073709551615
| int8    | 	Знаковые 8-битные целые числа      |	от -128 до 127
| int16   | 	Знаковые 16-битные целые числа     | 	от -32768 до 32767
| int32   | 	Знаковые 32-битные целые числа     | 	от -2147483648 до 2147483647
| int64   | 	Знаковые 64-битные целые числа     | 	от -9223372036854775808 до 9223372036854775807

В дополнение к этому существуют два типа-псевдонима: `byte` (то же самое, что `uint8`) и `rune` (то же самое, что `int32`).
Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип `byte` в Go часто используется для определения других типов.

Также существует 3 машинно-зависимых целочисленных типа: `uint`, `int` и `uintptr`.
Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера:

`int`: представляет целое число со знаком, которое в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо `int32`, либо `int64`.

`uint`: представляет целое число только без знака, которое, аналогично типу `int`, в зависимости от платформы может занимать либо 4 байта, либо 8 байт.
То есть соответствовать либо `uint32`, либо `uint64`.

В общем, если вы работаете с целыми числами — просто используйте тип `int`.


## Числа с плавающей точкой
**Числа с плавающей точкой** — это числа, которые содержат вещественную часть (вещественные числа) (1.234, 123.4, 0.00001234).
* Числа с плавающей точкой неточны. Бывают случаи, когда число вообще нельзя представить. Например, результатом вычисления 1.01 - 0.99 будет0.020000000000000018 - число очень близкое к ожидаемому, но не то же самое.
* Как и целые числа, числа с плавающей точкой имеют определенный размер (32 бита или 64 бита). Использование большего размера увеличивает точность (сколько цифр мы можем использовать для вычисления)
* В дополнение к числам существуют несколько других значений, таких как:  (`NaN`, для вещей наподобие 0/0), а также положительная и отрицательная бесконечность (`+∞` и `−∞`).

В Go есть два вещественных типа: `float32` и `float64` (соответственно часто называемые вещественными числами с одинарной и двойной точностью), а также два дополнительных типа для представления комплексных чисел (чисел с мнимой частью): `complex64` и `complex128`.
При работе с вещественными числами достаточно использовать `float32`, однако, если Вы хотите работать с более точными числами, можно использовать и `float64`. 


## Строки
Строка — это последовательность символов определенной длины, используемая для представления текста.
Строки в Go состоят из независимых байтов, обычно по одному на каждый символ (символы из других языков, таких как китайский, представляются несколькими байтами).

Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов \`Hello World\`.
Различие между ними в том, что строки в двойных кавычках не могут содержать новые строки и они позволяют использовать особые управляющие последовательности символов.
Например, `\n` будет заменена символом новой строки, а `\t` - символом табуляции.

Распространенные операции над строками включают в себя нахождение количества байт строки `len("Hello World")`, доступ к отдельному символу в строке `"Hello World"[1]` (строки “индексируются” начиная с 0, а не с 1), и конкатенацию двух строк `"Hello " + "World"`.

Так как строки в Go хранятся в виде байтов нужно понимать что такой код не выведет символ:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello Go"[0]) // вывод: 72
}
```

Представим байты в виде строки:
```go
package main

import "fmt"

func main() {
    fmt.Println(string("Hello Go"[0])) // вывод: H
}
```


## Логические типы
Булевый тип - `bool` (названный так в честь Джорджа Буля) — это специальный целочисленный тип, используемый для представления истинности и ложности.
Переменная такого типа будет занимать только один байт.
С этим типом используются три логических оператора:

| Литерал       | Пояснение |
|---------------|-----------|
| &&            | И         |
| &#124;&#124;  | 	ИЛИ      |
| !             | 	НЕ       |

Переменная типа `bool` может принимать только два значения: `truе` или `false`.


## Переменные
Для определения переменной применяется ключевое слово var, после которого идет имя переменной, а затем указывается ее тип:
```
var имя_переменной тип_данных
```

Имя переменной представляет произвольный идентификатор, который состоит из алфавитных и цифровых символов и символа подчеркивания. При этом первым символом должен быть либо алфавитный символ, либо символ подчеркивания.

При этом имена не должны представлять одно из ключевых слов: `break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var`.

Можно одновременно объявить сразу несколько переменных через запятую:
```go
var a, b, c string
```

Для хранения символов можно использовать `int32`/`rune`.
Здесь используются одинарные кавычки.
Компилятор определяет код буквы в unicode и присваивает его переменной symbol.
То есть мы не храним никакую 'c', а храним лишь число 99.
Функция `string()` из переданного в него числа 99 делает строку 'c'.
```go
var symbol int32 = 'c'
fmt.Println(string(symbol))
```

Также можно объявить сразу несколько переменных в одном блоке var:
```go
var (
    name string = "Dima"
    age int = 23
)
```


## Арифметические операции
У переменных есть разные операции, как в алгебре.
* \+ сложение
* \- вычитание
* \* умножение
* / деление
* % остаток от деления
* x++ инкремент
* x-- декремент


При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:
```go
var a int = 10 / 6
------------------
Вывод: 1
```

Чтобы получить в результате деления вещественное число,  как минимум один из операндов также должен представлять собой вещественное число и результат мы должны при этом тоже сохранять в переменную вещественного типа:
```go
var m float32 = 10.0 / 6
----------------------
Вывод: 1.6666666
```


## Константы
Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз.
Вычисление констант производится во время компиляции.
Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Для определения констант применяется ключевое слово `const`:
```go
const pi float64 = 3.1415
```

Константы, как и обычные переменные, можно объявлять в блоке:
```go
const (
	a int = 45
	b float32 = 3.3
)
```

Также можно не указывать значение следующей константы по порядку (значение будет скопировано):
```go
package main

import (
	"fmt"
)

const(
	A int = 45
	B
	C float32 = 3.3
	D
)

func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}
```


## iota
**iota** идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.

Сделаем дни недели с использованием iota - теперь это выглядит проще (особенно если много данных):  
```go
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

func main() {
	fmt.Println(Sunday)   // вывод 0
	fmt.Println(Saturday) // вывод 6
}
```

В объявлении константы предварительно объявленный идентификатор iota представляет последовательные не типизированные целочисленные константы.
Его значение является индексом соответствующего ConstSpec в объявлении константы, начиная с нуля.
Поскольку он может использоваться в выражениях, он обеспечивает общность, выходящую за рамки простых перечислений.
Его можно использовать для построения набора связанных констант, ознакомьтесь с примерами:
```go
const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2


const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8



const (
	u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0
```


## Условные выражения
Условные выражения представляют операции отношения и логические операции.
Они представляют некоторое условие и возвращают значение типа `bool`: `true` (если условие истинно) или `false` (если условие ложно).

### Операции отношения
Операции отношения позволяют сравнить два значения.
В языке Go есть следующие операции отношения:
* ==
* \>
* <
* <=
* \>=
* !=

### Логические операции
Логические операции сравнивают два условия.
Как правило, они применяются к отношениям и объединяют несколько операций отношения.

К логическим операциям относят следующие:
* ! (операция отрицания, логическое НЕ)
* && (конъюнкция, логическое умножение,  логическое И)
* || (дизъюнкция, логическое сложение, логическое ИЛИ)


## Условные конструкции
### Условная конструкция if
Конструкция if принимает условие - выражение, которое возвращает значение типа `bool`.
Если это условие истинно, то выполняется последующий блок инструкций:
```go
package main

import "fmt"

func main() {
   a := 6    
   b := 7
   if a < b {     
      fmt.Println("a меньше, чем b")  
   }
}
```

### If с краткой инструкцией

Так же как и `for` (про него в следующем уроке), оператор `if` может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные, объявленные в этом блоке, доступны только в области видимости, которая существует до конца `if`.
Пример:
```go
if v := math.Pow(x, n); v < lim {
   // ...
}
```

### Условные конструкции else if и else
Если нам нужно проверить несколько условий, мы можем использовать оператор `else if`:
```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
}
```

Если нам нужен вариант, когда ни одно из условий не выполняется, то мы используем оператор `else`:
```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}
```

### Switch
Go содержит в себе другой оператор, позволяющий делать перечисления: оператор switch (переключатель).
С ним программа может выглядеть так:
```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

Переключатель начинается с ключевого слова `switch`, за которым следует выражение (в нашем случае `i`) и серия возможных значений (`case`).
Значение выражения по очереди сравнивается с выражениями, следующими после ключевого слова `case`.
Если они оказываются равны, то выполняется действие, описанное после `:`.

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение, которое сошлось с выражением.
Переключатель также поддерживает действие по умолчанию, которое будет выполнено в случае, если не подошло ни одно из возможных значений (напоминает `else` в операторе `if`).

В `switch` можно использовать любой тип данных.

#### Стоит дополнить, что:
1.  В Go код после case выполняется до следующего case, и нет нужды каждый `case`-блок заканчивать ключевым словом **break** (данная особенность добавлена в язык специально, чтобы уменьшить количество ошибок в switch-блоках).
 
    Если в текущем case написать `fallthrough`, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего `case`) условие:
    ```go
    v := 42
    switch v {
    case 100:
        fmt.Println(100)
        fallthrough
    case 42:
        fmt.Println(42)
        fallthrough
    case 1:
        fmt.Println(1)
        fallthrough
    default:
        fmt.Println("default")
    }
    // Вывод:
    // 42
    // 1
    // default
    ```
2.  Существует специальная форма `switch`, допускающая использование произвольных условий в каждом `case`-блоке:
    ```go
    var c uint32
    fmt.Scan(&c)
    switch {
    case 1 <= c && c <= 9:
        fmt.Println("от 1 до 9")
    case 100 <= c && c <= 250:
        fmt.Println("от 100 до 250")
    case 1000 <= c && c <= 6000:
        fmt.Println("от 1000 до 6000")
    }
    ```
    
    То есть, сразу после switch "переключатель" не нужен, а после каждого `case` идет выражение с произвольным условием.

## Задания блока "1.9 Условные конструкции"
<details><summary>Раскрыть</summary>

### Step 5
На ввод подается целое число.
Если число положительное - вывести сообщение "Число положительное", если число отрицательное - "Число отрицательное".
Если подается ноль - вывести сообщение "Ноль". Выводить сообщение без кавычек.

**Sample Input**: 5

**Sample Output**: Число положительное

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  if iData > 0 {
    fmt.Println("Число положительное")
  } else if iData < 0 {
    fmt.Println("Число отрицательное")
  } else {
    fmt.Println("Ноль")
  }
}
```

### Step 6
По данному трехзначному числу определите, все ли его цифры различны.

**Формат входных данных**

На вход подается одно натуральное трехзначное число.

**Формат выходных данных**

Выведите "YES", если все цифры числа различны, в противном случае - "NO".

**Sample Input 1**: 237

**Sample Output 1**: YES

**Sample Input 2**: 117

**Sample Output 2**: NO

```go
package main

import "fmt"

func main() {
  var i1, i2, i3, iData int
  fmt.Scan(&iData)
  
  i1 = iData / 100
  i2 = (iData % 100) / 10
  i3 = iData % 10
  
  if i1 != i2 && i1 != i3 && i2 != i3 {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

### Step 7
Дано неотрицательное целое число. Найдите и выведите первую цифру числа. 

**Формат входных данных**

На вход дается натуральное число, не превосходящее 10000.

**Формат выходных данных**

Выведите одно целое число - первую цифру заданного числа.

**Sample Input**: 1234

**Sample Output**: 1

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  
  switch {
  case iData < 10:
    fmt.Println(iData)
  case iData >= 10 && iData < 100:
    fmt.Println(iData / 10)
  case iData >= 100 && iData < 1000:
    fmt.Println(iData / 100)
  case iData >= 1000 && iData < 10000:
    fmt.Println(iData / 1000)
  default:
    fmt.Println(1)
  }
}
```

### Step 8
Определите является ли билет счастливым. Счастливым считается билет, в шестизначном номере которого сумма первых трёх цифр совпадает с суммой трёх последних.

**Формат входных данных**

На вход подается номер билета - одно шестизначное  число.

**Формат выходных данных**

Выведите "YES", если билет счастливый, в противном случае - "NO".

**Sample Input**: 613244

**Sample Output**: YES

```go
package main

import "fmt"

func main() {
  var iData int
  var numb [6]int  
  fmt.Scan(&iData)
  
  numb[0] = iData / 100000
  numb[1] = (iData % 100000) / 10000
  numb[2] = (iData % 10000) / 1000
  numb[3] = (iData % 1000) / 100
  numb[4] = (iData % 100) / 10
  numb[5] = iData % 10
  
  if numb[0] + numb[1] + numb[2] == numb[3] + numb[4] + numb[5] {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

### Step 9
Требуется определить, является ли данный год високосным, напомним:

Год является високосным если он соответствует хотя бы одному из нижеперечисленных условий:
- кратен 400;
- кратен 4, но не кратен 100.

**Входные данные**

Вводится единственное число - номер года (целое, положительное, не превышает 10000).

**Выходные данные**

Требуется вывести слово YES, если год является високосным и NO - в противном случае.

**Sample Input**: 2000

**Sample Output**: YES

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  
  if iData % 400 == 0 {
    fmt.Println("YES")
  } else if iData % 4 == 0 && iData % 100 != 0 {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

</details>


## Циклы в Go
Единственной конструкцией для циклов в Go является оператор `for`.

Его базовая форма выглядит следующим образом:
```
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
```

Пример использования:
```go
package main

import "fmt"

func main() {
	sum := 0
	for i := 1; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

Объявление цикла `for` разбивается на три части.
Вначале идет инициализация счетчика: `i := 1`.
Фактически она представляет объявление переменной, которая будет использоваться внутри цикла.
В данном случае это счетчик `i`, начальное значение которого равно 1.

Вторая часть представляет условие: `i < 10`.
Пока это условие истинно, то есть возвращает `true`, будет продолжаться цикл.

Третья часть представляет изменение (увеличение) счетчика на единицу.

Нам необязательно указывать все условия при объявлении цикла.
Например, можно вынести объявление переменной вовне:
```go
var i = 1
for ; i < 10; i++{
    fmt.Println(i * i)
}
```

Можно убрать изменение счетчика в само тело цикла и оставить только условие:
```go
var i = 1
for ; i < 10;{
    fmt.Println(i * i)
    i++
}
```

Если цикл использует только условие, то его можно сократить следующим образом:
```go
var i = 1
for i < 10{
    fmt.Println(i * i)
    i++
}
```

При этом в последнем случае мы получим по сути аналог цикла `while` в других языках программирования.

Так же можно реализовать бесконечный цикл:
```go
for {

}
```

**Кстати**, иногда удобно пользоваться такой конструкцией ввода данных:

(но будьте осторожны, ведь мы не обрабатываем здесь ошибки)
```go
var n int
// считываем числа пока не будет введен 0
for fmt.Scan(&n); n != 0; fmt.Scan(&n){
	fmt.Println(n)
}
```

## Задания 2-5
<details><summary>Раскрыть</summary>

### Задание 2
Напишите программу, которая выводит квадраты натуральных чисел от 1 до 10.
Квадрат каждого числа должен выводится в новой строке.
```go
package main

import "fmt"

func main() {
    for i := 1; i <= 10; i++ {
        fmt.Println(i * i)   
    }
}
```

### Задание 3
Требуется написать программу, при выполнении которой с клавиатуры считываются два натуральных числа A и B (каждое не более 100, A < B).
Вывести сумму всех чисел от A до B включительно.

**Sample Input**: 1 5
**Sample Output**: 15

```go
package main

import "fmt"

func main() {
    var A, B, out int
    
    fmt.Scan(&A, &B)
    
    for i := A; i <= B; i++ {
        out = out + i
    }
    
    fmt.Println(out)
}
```

### Задание 4
Напишите программу, которая в последовательности чисел находит сумму двузначных чисел, кратных 8.
Программа в первой строке получает на вход число n - количество чисел в последовательности, во второй строке -- n чисел, входящих в данную последовательность.

**Sample Input**:

5

38 24 800 8 16

**Sample Output**: 40

```go
package main

import "fmt"

func main() {
    var n, iData, out int
    
    fmt.Scan(&n)
    
    for i := 0; i < n; i++ {
        fmt.Scan(&iData)
        if iData >= 10 && iData < 100 && iData % 8 == 0 {
            out = out + iData
        }
    }
    
    fmt.Println(out)
}
```

### Step 5
Последовательность состоит из натуральных чисел и завершается числом 0.
Определите количество элементов этой последовательности, которые равны ее наибольшему элементу.

**Формат входных данных**

Вводится непустая последовательность натуральных чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).

**Формат выходных данных**

Выведите ответ на задачу.

**Sample Input**:

1

3

3

1

0

**Sample Output**: 2

```go
package main

import "fmt"

func main() {
    var iData, iMax, oData int
    
    for fmt.Scan(&iData); iData != 0; fmt.Scan(&iData){
        if iData > iMax {
            iMax = iData
            oData = 1
        } else if iData == iMax {
            oData++
        }
    }
    
    fmt.Println(oData)
}
```

</details>


### Операторы break и continue
Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а сразу перейти к следующей итерации.
В этом случае можно использовать оператор `continue`.
Например, нам нужно в диапазоне от 1 до 10 посчитать сумму нечетных чисел.
Если нам встретится четное число, мы можем просто перейти к следующей итерации с помощью `continue`:
```go
var sum = 0
 
for i := 1; i <= 10; i++{
    if i % 2 == 0 {
        continue        // переходим к следующей итерации
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 25
```

Оператор `break` полностью осуществляет выход из цикла:
```go
var sum = 0
 
for i := 1; i <= 9; i++{
    if i > 4 {
        break       // если число больше 4 выходим из цикла
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 10
```

## Задания 7-10
<details><summary>Раскрыть</summary>

### Step 7
Найдите первое число от 1 до n включительно, кратное c, но НЕ кратное d.

**Входные данные**

Вводится 3 натуральных числа n, c, d, каждое из которых не превышает 10000.

**Выходные данные**

Вывести первое число от 1 до n включительно, кратное c, но НЕ кратное d. Если такого числа нет - выводить ничего не нужно.

**Sample Input**: 20 3 5
**Sample Output**: 3

```go
package main

import "fmt"

func main() {
    var n, c, d int
    fmt.Scan(&n, &c, &d)
    
    for i := 1; i <= n; i++ {
        if (i % c == 0) && (i % d != 0) {
            fmt.Println(i)
            break
        }
    }
}
```

### Step 8
Напишите программу, которая считывает целые числа с консоли по одному числу в строке.

Для каждого введённого числа проверить:
* если число меньше 10, то пропускаем это число;
* если число больше 100, то прекращаем считывать числа;
* в остальных случаях вывести это число обратно на консоль в отдельной строке.
---
**Sample Input**:

30

11

7

101

---
**Sample Output**:

30

11

---
```go
package main

import "fmt"

func main() {
    var iData int
    
    for fmt.Scan(&iData); iData <= 100; fmt.Scan(&iData) {
        if iData >= 10 {
            fmt.Println(iData)
        }
    }
}
```

### Step 9
Вклад в банке составляет x рублей.
Ежегодно он увеличивается на p процентов, после чего дробная часть копеек отбрасывается.
Каждый год сумма вклада становится больше.
Определите, через сколько лет вклад составит не менее y рублей.

**Входные данные**

Программа получает на вход три натуральных числа: x, p, y.

**Выходные данные**

Программа должна вывести одно целое число.

---
**Sample Input**: 100 10 200

---
**Sample Output**: 8

---
```go
package main

import "fmt"

func main() {
    var x, y, oData int
    var p float32
    
    fmt.Scan(&x, &p, &y)
    p = p / 100 + 1
    
    for {
        x = int(float32(x) * p)
        oData++
        if x >= y {
            fmt.Println(oData)
            break
        }
    }
}
```

### Step 10
Даны два числа.
Определить цифры, входящие в запись как первого, так и второго числа.

**Входные данные**

Программа получает на вход два числа.
Гарантируется, что цифры в числах не повторяются.
Числа в пределах от 0 до 10000.

**Выходные данные**

Программа должна вывести цифры, которые имеются в обоих числах, через пробел.
Цифры выводятся в порядке их нахождения в первом числе.

---
**Sample Input**: 564 8954

---
**Sample Output**: 5 4

---
```go
package main

import "fmt"

func main() {
    var iData1, iData2 string
    
    fmt.Scan(&iData1, &iData2)
    
    for i := 0; i < len(iData1); i++ {
        for k := 0; k < len(iData2); k++ {
            if iData1[i] == iData2[k] {
                fmt.Print(string(iData1[i]), " ")
            }
        }
    }
}
```

</details>