# Основы
## Целые числа
В Go существуют следующие типы целых чисел: `uint8`, `uint16`, `uint32`, `uint64`, `int8`, `int16`, `int32` и `int64`.
8, 16, 32 и 64 говорит нам, сколько бит использует каждый тип.
`uint` означает «unsigned integer» (беззнаковое целое), в то время как `int` означает «signed integer» (знаковое целое).
Беззнаковое целое может принимать только положительные значения (или ноль).


| Тип     | Описание                               | Принимаемые значения |
|---------|----------------------------------------| --- |
| uint8   | Беззнаковые 8-битные целые числа       |    от 0 до 255
| uint16  | Беззнаковые 16-битные целые числа      |    от 0 до 65535
| uint32  | Беззнаковые 32-битные целые числа      |	от 0 до 4294967295
| uint64  | 	Беззнаковые 64-битные целые числа  | 	от 0 до 18446744073709551615
| int8    | 	Знаковые 8-битные целые числа      |	от -128 до 127
| int16   | 	Знаковые 16-битные целые числа     | 	от -32768 до 32767
| int32   | 	Знаковые 32-битные целые числа     | 	от -2147483648 до 2147483647
| int64   | 	Знаковые 64-битные целые числа     | 	от -9223372036854775808 до 9223372036854775807

В дополнение к этому существуют два типа-псевдонима: `byte` (то же самое, что `uint8`) и `rune` (то же самое, что `int32`).
Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип `byte` в Go часто используется для определения других типов.

Также существует 3 машинно-зависимых целочисленных типа: `uint`, `int` и `uintptr`.
Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера:

`int`: представляет целое число со знаком, которое в зависимости от платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо `int32`, либо `int64`.

`uint`: представляет целое число только без знака, которое, аналогично типу `int`, в зависимости от платформы может занимать либо 4 байта, либо 8 байт.
То есть соответствовать либо `uint32`, либо `uint64`.

В общем, если вы работаете с целыми числами — просто используйте тип `int`.


## Числа с плавающей точкой
**Числа с плавающей точкой** — это числа, которые содержат вещественную часть (вещественные числа) (1.234, 123.4, 0.00001234).
* Числа с плавающей точкой неточны. Бывают случаи, когда число вообще нельзя представить. Например, результатом вычисления 1.01 - 0.99 будет0.020000000000000018 - число очень близкое к ожидаемому, но не то же самое.
* Как и целые числа, числа с плавающей точкой имеют определенный размер (32 бита или 64 бита). Использование большего размера увеличивает точность (сколько цифр мы можем использовать для вычисления)
* В дополнение к числам существуют несколько других значений, таких как:  (`NaN`, для вещей наподобие 0/0), а также положительная и отрицательная бесконечность (`+∞` и `−∞`).

В Go есть два вещественных типа: `float32` и `float64` (соответственно часто называемые вещественными числами с одинарной и двойной точностью), а также два дополнительных типа для представления комплексных чисел (чисел с мнимой частью): `complex64` и `complex128`.
При работе с вещественными числами достаточно использовать `float32`, однако, если Вы хотите работать с более точными числами, можно использовать и `float64`. 


## Строки
Строка — это последовательность символов определенной длины, используемая для представления текста.
Строки в Go состоят из независимых байтов, обычно по одному на каждый символ (символы из других языков, таких как китайский, представляются несколькими байтами).

Строковые литералы могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов \`Hello World\`.
Различие между ними в том, что строки в двойных кавычках не могут содержать новые строки и они позволяют использовать особые управляющие последовательности символов.
Например, `\n` будет заменена символом новой строки, а `\t` - символом табуляции.

Распространенные операции над строками включают в себя нахождение количества байт строки `len("Hello World")`, доступ к отдельному символу в строке `"Hello World"[1]` (строки “индексируются” начиная с 0, а не с 1), и конкатенацию двух строк `"Hello " + "World"`.

Так как строки в Go хранятся в виде байтов нужно понимать что такой код не выведет символ:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello Go"[0]) // вывод: 72
}
```

Представим байты в виде строки:
```go
package main

import "fmt"

func main() {
    fmt.Println(string("Hello Go"[0])) // вывод: H
}
```


## Логические типы
Булевый тип - `bool` (названный так в честь Джорджа Буля) — это специальный целочисленный тип, используемый для представления истинности и ложности.
Переменная такого типа будет занимать только один байт.
С этим типом используются три логических оператора:

| Литерал       | Пояснение |
|---------------|-----------|
| &&            | И         |
| &#124;&#124;  | 	ИЛИ      |
| !             | 	НЕ       |

Переменная типа `bool` может принимать только два значения: `truе` или `false`.


## Переменные
Для определения переменной применяется ключевое слово var, после которого идет имя переменной, а затем указывается ее тип:
```
var имя_переменной тип_данных
```

Имя переменной представляет произвольный идентификатор, который состоит из алфавитных и цифровых символов и символа подчеркивания. При этом первым символом должен быть либо алфавитный символ, либо символ подчеркивания.

При этом имена не должны представлять одно из ключевых слов: `break, case, chan, const, continue, default, defer, else, fallthrough, for, func, go, goto, if, import, interface, map, package, range, return, select, struct, switch, type, var`.

Можно одновременно объявить сразу несколько переменных через запятую:
```go
var a, b, c string
```

Для хранения символов можно использовать `int32`/`rune`.
Здесь используются одинарные кавычки.
Компилятор определяет код буквы в unicode и присваивает его переменной symbol.
То есть мы не храним никакую 'c', а храним лишь число 99.
Функция `string()` из переданного в него числа 99 делает строку 'c'.
```go
var symbol int32 = 'c'
fmt.Println(string(symbol))
```

Также можно объявить сразу несколько переменных в одном блоке var:
```go
var (
    name string = "Dima"
    age int = 23
)
```


## Арифметические операции
У переменных есть разные операции, как в алгебре.
* \+ сложение
* \- вычитание
* \* умножение
* / деление
* % остаток от деления
* x++ инкремент
* x-- декремент


При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа:
```go
var a int = 10 / 6
------------------
Вывод: 1
```

Чтобы получить в результате деления вещественное число,  как минимум один из операндов также должен представлять собой вещественное число и результат мы должны при этом тоже сохранять в переменную вещественного типа:
```go
var m float32 = 10.0 / 6
----------------------
Вывод: 1.6666666
```


## Константы
Константы, как и переменные, хранят некоторые данные, но, в отличие от переменных, значения констант нельзя изменить, они устанавливаются один раз.
Вычисление констант производится во время компиляции.
Благодаря этому уменьшается количество работы, которую необходимо произвести во время выполнения, упрощается поиск ошибок, связанных с константами (так как некоторые из них можно обнаружить на момент компиляции).

Для определения констант применяется ключевое слово `const`:
```go
const pi float64 = 3.1415
```

Константы, как и обычные переменные, можно объявлять в блоке:
```go
const (
	a int = 45
	b float32 = 3.3
)
```

Также можно не указывать значение следующей константы по порядку (значение будет скопировано):
```go
package main

import (
	"fmt"
)

const(
	A int = 45
	B
	C float32 = 3.3
	D
)

func main() {
	fmt.Println(A, B, C, D)  // Вывод: 45 45 3.3 3.3
}
```


## iota
**iota** идентификатор Go используется в объявлениях констант для упрощения определений увеличивающихся чисел.

Сделаем дни недели с использованием iota - теперь это выглядит проще (особенно если много данных):  
```go
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)

func main() {
	fmt.Println(Sunday)   // вывод 0
	fmt.Println(Saturday) // вывод 6
}
```

В объявлении константы предварительно объявленный идентификатор iota представляет последовательные не типизированные целочисленные константы.
Его значение является индексом соответствующего ConstSpec в объявлении константы, начиная с нуля.
Поскольку он может использоваться в выражениях, он обеспечивает общность, выходящую за рамки простых перечислений.
Его можно использовать для построения набора связанных констант, ознакомьтесь с примерами:
```go
const (
  c0 = iota  // c0 == 0
  c1 = iota  // c1 == 1
  c2 = iota  // c2 == 2
)
fmt.Println(c0, c1, c2) // вывод: 0 1 2


const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
	_  // пропускаем 7
	Add
)

fmt.Println(Sunday)   // вывод: 0
fmt.Println(Saturday) // вывод: 6
fmt.Println(Add) // вывод: 8



const (
	u         = iota * 42 // u == 0 (индекс - 0, поэтому 0 * 42 = 0)
	v float64 = iota * 42 // v == 42.0 (индекс - 1, поэтому 1.0 * 42 = 42.0)
	w         = iota * 42 // w == 84  (индекс - 2, поэтому 2 * 42 = 84)
)

// переменные ни в одном блоке const, поэтому индекс не увеличился
const x = iota  // x == 0
const y = iota  // y == 0
```


## Условные выражения
Условные выражения представляют операции отношения и логические операции.
Они представляют некоторое условие и возвращают значение типа `bool`: `true` (если условие истинно) или `false` (если условие ложно).

### Операции отношения
Операции отношения позволяют сравнить два значения.
В языке Go есть следующие операции отношения:
* ==
* \>
* <
* <=
* \>=
* !=

### Логические операции
Логические операции сравнивают два условия.
Как правило, они применяются к отношениям и объединяют несколько операций отношения.

К логическим операциям относят следующие:
* ! (операция отрицания, логическое НЕ)
* && (конъюнкция, логическое умножение,  логическое И)
* || (дизъюнкция, логическое сложение, логическое ИЛИ)


## Условные конструкции
### Условная конструкция if
Конструкция if принимает условие - выражение, которое возвращает значение типа `bool`.
Если это условие истинно, то выполняется последующий блок инструкций:
```go
package main

import "fmt"

func main() {
   a := 6    
   b := 7
   if a < b {     
      fmt.Println("a меньше, чем b")  
   }
}
```

### If с краткой инструкцией

Так же как и `for` (про него в следующем уроке), оператор `if` может начинаться с инструкции, которая будет выполнена перед проверкой условия.

Переменные, объявленные в этом блоке, доступны только в области видимости, которая существует до конца `if`.
Пример:
```go
if v := math.Pow(x, n); v < lim {
   // ...
}
```

### Условные конструкции else if и else
Если нам нужно проверить несколько условий, мы можем использовать оператор `else if`:
```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
}
```

Если нам нужен вариант, когда ни одно из условий не выполняется, то мы используем оператор `else`:
```go
if a < b {
    fmt.Println("a меньше b")
} else if a > b {
    fmt.Println("a больше b")
} else {
    fmt.Println("a равно b")
}
```

### Switch
Go содержит в себе другой оператор, позволяющий делать перечисления: оператор switch (переключатель).
С ним программа может выглядеть так:
```go
switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}
```

Переключатель начинается с ключевого слова `switch`, за которым следует выражение (в нашем случае `i`) и серия возможных значений (`case`).
Значение выражения по очереди сравнивается с выражениями, следующими после ключевого слова `case`.
Если они оказываются равны, то выполняется действие, описанное после `:`.

Как и условия, обход возможных значений осуществляется сверху вниз, и выбирается первое значение, которое сошлось с выражением.
Переключатель также поддерживает действие по умолчанию, которое будет выполнено в случае, если не подошло ни одно из возможных значений (напоминает `else` в операторе `if`).

В `switch` можно использовать любой тип данных.

#### Стоит дополнить, что:
1.  В Go код после case выполняется до следующего case, и нет нужды каждый `case`-блок заканчивать ключевым словом **break** (данная особенность добавлена в язык специально, чтобы уменьшить количество ошибок в switch-блоках).
 
    Если в текущем case написать `fallthrough`, то тело следующего case выполнится вне зависимости от того истинно ли его (следующего `case`) условие:
    ```go
    v := 42
    switch v {
    case 100:
        fmt.Println(100)
        fallthrough
    case 42:
        fmt.Println(42)
        fallthrough
    case 1:
        fmt.Println(1)
        fallthrough
    default:
        fmt.Println("default")
    }
    // Вывод:
    // 42
    // 1
    // default
    ```
2.  Существует специальная форма `switch`, допускающая использование произвольных условий в каждом `case`-блоке:
    ```go
    var c uint32
    fmt.Scan(&c)
    switch {
    case 1 <= c && c <= 9:
        fmt.Println("от 1 до 9")
    case 100 <= c && c <= 250:
        fmt.Println("от 100 до 250")
    case 1000 <= c && c <= 6000:
        fmt.Println("от 1000 до 6000")
    }
    ```
    
    То есть, сразу после switch "переключатель" не нужен, а после каждого `case` идет выражение с произвольным условием.

## Задания блока "1.9 Условные конструкции"
<details><summary>Раскрыть</summary>

### Step 5
На ввод подается целое число.
Если число положительное - вывести сообщение "Число положительное", если число отрицательное - "Число отрицательное".
Если подается ноль - вывести сообщение "Ноль". Выводить сообщение без кавычек.

**Sample Input**: 5

**Sample Output**: Число положительное

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  if iData > 0 {
    fmt.Println("Число положительное")
  } else if iData < 0 {
    fmt.Println("Число отрицательное")
  } else {
    fmt.Println("Ноль")
  }
}
```

### Step 6
По данному трехзначному числу определите, все ли его цифры различны.

**Формат входных данных**

На вход подается одно натуральное трехзначное число.

**Формат выходных данных**

Выведите "YES", если все цифры числа различны, в противном случае - "NO".

**Sample Input 1**: 237

**Sample Output 1**: YES

**Sample Input 2**: 117

**Sample Output 2**: NO

```go
package main

import "fmt"

func main() {
  var i1, i2, i3, iData int
  fmt.Scan(&iData)
  
  i1 = iData / 100
  i2 = (iData % 100) / 10
  i3 = iData % 10
  
  if i1 != i2 && i1 != i3 && i2 != i3 {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

### Step 7
Дано неотрицательное целое число. Найдите и выведите первую цифру числа. 

**Формат входных данных**

На вход дается натуральное число, не превосходящее 10000.

**Формат выходных данных**

Выведите одно целое число - первую цифру заданного числа.

**Sample Input**: 1234

**Sample Output**: 1

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  
  switch {
  case iData < 10:
    fmt.Println(iData)
  case iData >= 10 && iData < 100:
    fmt.Println(iData / 10)
  case iData >= 100 && iData < 1000:
    fmt.Println(iData / 100)
  case iData >= 1000 && iData < 10000:
    fmt.Println(iData / 1000)
  default:
    fmt.Println(1)
  }
}
```

### Step 8
Определите является ли билет счастливым. Счастливым считается билет, в шестизначном номере которого сумма первых трёх цифр совпадает с суммой трёх последних.

**Формат входных данных**

На вход подается номер билета - одно шестизначное  число.

**Формат выходных данных**

Выведите "YES", если билет счастливый, в противном случае - "NO".

**Sample Input**: 613244

**Sample Output**: YES

```go
package main

import "fmt"

func main() {
  var iData int
  var numb [6]int  
  fmt.Scan(&iData)
  
  numb[0] = iData / 100000
  numb[1] = (iData % 100000) / 10000
  numb[2] = (iData % 10000) / 1000
  numb[3] = (iData % 1000) / 100
  numb[4] = (iData % 100) / 10
  numb[5] = iData % 10
  
  if numb[0] + numb[1] + numb[2] == numb[3] + numb[4] + numb[5] {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

### Step 9
Требуется определить, является ли данный год високосным, напомним:

Год является високосным если он соответствует хотя бы одному из нижеперечисленных условий:
- кратен 400;
- кратен 4, но не кратен 100.

**Входные данные**

Вводится единственное число - номер года (целое, положительное, не превышает 10000).

**Выходные данные**

Требуется вывести слово YES, если год является високосным и NO - в противном случае.

**Sample Input**: 2000

**Sample Output**: YES

```go
package main

import "fmt"

func main() {
  var iData int
  fmt.Scan(&iData)
  
  if iData % 400 == 0 {
    fmt.Println("YES")
  } else if iData % 4 == 0 && iData % 100 != 0 {
    fmt.Println("YES")
  } else {
    fmt.Println("NO")
  }
}
```

</details>


## Циклы в Go
Единственной конструкцией для циклов в Go является оператор `for`.

Его базовая форма выглядит следующим образом:
```
for [инициализация счетчика]; [условие]; [изменение счетчика]{
    // действия
}
```

Пример использования:
```go
package main

import "fmt"

func main() {
	sum := 0
	for i := 1; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

Объявление цикла `for` разбивается на три части.
Вначале идет инициализация счетчика: `i := 1`.
Фактически она представляет объявление переменной, которая будет использоваться внутри цикла.
В данном случае это счетчик `i`, начальное значение которого равно 1.

Вторая часть представляет условие: `i < 10`.
Пока это условие истинно, то есть возвращает `true`, будет продолжаться цикл.

Третья часть представляет изменение (увеличение) счетчика на единицу.

Нам необязательно указывать все условия при объявлении цикла.
Например, можно вынести объявление переменной вовне:
```go
var i = 1
for ; i < 10; i++{
    fmt.Println(i * i)
}
```

Можно убрать изменение счетчика в само тело цикла и оставить только условие:
```go
var i = 1
for ; i < 10;{
    fmt.Println(i * i)
    i++
}
```

Если цикл использует только условие, то его можно сократить следующим образом:
```go
var i = 1
for i < 10{
    fmt.Println(i * i)
    i++
}
```

При этом в последнем случае мы получим по сути аналог цикла `while` в других языках программирования.

Так же можно реализовать бесконечный цикл:
```go
for {

}
```

**Кстати**, иногда удобно пользоваться такой конструкцией ввода данных:

(но будьте осторожны, ведь мы не обрабатываем здесь ошибки)
```go
var n int
// считываем числа пока не будет введен 0
for fmt.Scan(&n); n != 0; fmt.Scan(&n){
	fmt.Println(n)
}
```

## Задания 2-5
<details><summary>Раскрыть</summary>

### Задание 2
Напишите программу, которая выводит квадраты натуральных чисел от 1 до 10.
Квадрат каждого числа должен выводится в новой строке.
```go
package main

import "fmt"

func main() {
    for i := 1; i <= 10; i++ {
        fmt.Println(i * i)   
    }
}
```

### Задание 3
Требуется написать программу, при выполнении которой с клавиатуры считываются два натуральных числа A и B (каждое не более 100, A < B).
Вывести сумму всех чисел от A до B включительно.

**Sample Input**: 1 5
**Sample Output**: 15

```go
package main

import "fmt"

func main() {
    var A, B, out int
    
    fmt.Scan(&A, &B)
    
    for i := A; i <= B; i++ {
        out = out + i
    }
    
    fmt.Println(out)
}
```

### Задание 4
Напишите программу, которая в последовательности чисел находит сумму двузначных чисел, кратных 8.
Программа в первой строке получает на вход число n - количество чисел в последовательности, во второй строке -- n чисел, входящих в данную последовательность.

**Sample Input**:

5

38 24 800 8 16

**Sample Output**: 40

```go
package main

import "fmt"

func main() {
    var n, iData, out int
    
    fmt.Scan(&n)
    
    for i := 0; i < n; i++ {
        fmt.Scan(&iData)
        if iData >= 10 && iData < 100 && iData % 8 == 0 {
            out = out + iData
        }
    }
    
    fmt.Println(out)
}
```

### Step 5
Последовательность состоит из натуральных чисел и завершается числом 0.
Определите количество элементов этой последовательности, которые равны ее наибольшему элементу.

**Формат входных данных**

Вводится непустая последовательность натуральных чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).

**Формат выходных данных**

Выведите ответ на задачу.

**Sample Input**:

1

3

3

1

0

**Sample Output**: 2

```go
package main

import "fmt"

func main() {
    var iData, iMax, oData int
    
    for fmt.Scan(&iData); iData != 0; fmt.Scan(&iData){
        if iData > iMax {
            iMax = iData
            oData = 1
        } else if iData == iMax {
            oData++
        }
    }
    
    fmt.Println(oData)
}
```

</details>


### Операторы break и continue
Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла, а сразу перейти к следующей итерации.
В этом случае можно использовать оператор `continue`.
Например, нам нужно в диапазоне от 1 до 10 посчитать сумму нечетных чисел.
Если нам встретится четное число, мы можем просто перейти к следующей итерации с помощью `continue`:
```go
var sum = 0
 
for i := 1; i <= 10; i++{
    if i % 2 == 0 {
        continue        // переходим к следующей итерации
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 25
```

Оператор `break` полностью осуществляет выход из цикла:
```go
var sum = 0
 
for i := 1; i <= 9; i++{
    if i > 4 {
        break       // если число больше 4 выходим из цикла
    }
    sum += i
}
fmt.Println("Сумма: ", sum)    // Сумма: 10
```

## Задания 7-10
<details><summary>Раскрыть</summary>

### Step 7
Найдите первое число от 1 до n включительно, кратное c, но НЕ кратное d.

**Входные данные**

Вводится 3 натуральных числа n, c, d, каждое из которых не превышает 10000.

**Выходные данные**

Вывести первое число от 1 до n включительно, кратное c, но НЕ кратное d. Если такого числа нет - выводить ничего не нужно.

**Sample Input**: 20 3 5
**Sample Output**: 3

```go
package main

import "fmt"

func main() {
    var n, c, d int
    fmt.Scan(&n, &c, &d)
    
    for i := 1; i <= n; i++ {
        if (i % c == 0) && (i % d != 0) {
            fmt.Println(i)
            break
        }
    }
}
```

### Step 8
Напишите программу, которая считывает целые числа с консоли по одному числу в строке.

Для каждого введённого числа проверить:
* если число меньше 10, то пропускаем это число;
* если число больше 100, то прекращаем считывать числа;
* в остальных случаях вывести это число обратно на консоль в отдельной строке.
---
**Sample Input**:

30

11

7

101

---
**Sample Output**:

30

11

---
```go
package main

import "fmt"

func main() {
    var iData int
    
    for fmt.Scan(&iData); iData <= 100; fmt.Scan(&iData) {
        if iData >= 10 {
            fmt.Println(iData)
        }
    }
}
```

### Step 9
Вклад в банке составляет x рублей.
Ежегодно он увеличивается на p процентов, после чего дробная часть копеек отбрасывается.
Каждый год сумма вклада становится больше.
Определите, через сколько лет вклад составит не менее y рублей.

**Входные данные**

Программа получает на вход три натуральных числа: x, p, y.

**Выходные данные**

Программа должна вывести одно целое число.

---
**Sample Input**: 100 10 200

---
**Sample Output**: 8

---
```go
package main

import "fmt"

func main() {
    var x, y, oData int
    var p float32
    
    fmt.Scan(&x, &p, &y)
    p = p / 100 + 1
    
    for {
        x = int(float32(x) * p)
        oData++
        if x >= y {
            fmt.Println(oData)
            break
        }
    }
}
```

### Step 10
Даны два числа.
Определить цифры, входящие в запись как первого, так и второго числа.

**Входные данные**

Программа получает на вход два числа.
Гарантируется, что цифры в числах не повторяются.
Числа в пределах от 0 до 10000.

**Выходные данные**

Программа должна вывести цифры, которые имеются в обоих числах, через пробел.
Цифры выводятся в порядке их нахождения в первом числе.

---
**Sample Input**: 564 8954

---
**Sample Output**: 5 4

---
```go
package main

import "fmt"

func main() {
    var iData1, iData2 string
    
    fmt.Scan(&iData1, &iData2)
    
    for i := 0; i < len(iData1); i++ {
        for k := 0; k < len(iData2); k++ {
            if iData1[i] == iData2[k] {
                fmt.Print(string(iData1[i]), " ")
            }
        }
    }
}
```

</details>


## Форматированный вывод
`fmt.Printf()` на вход принимает сначала строку форматирования, а только потом переменные для вывода.
Строка форматирования представляет набор спецификаторов.
Каждый спецификатор представляет набор символов, которые интерпретируются определенным образом и предваряются знаком процента `%`.

Каждый спецификатор представляет определенный тип данных:
* `%t`: для вывода значений типа boolean (true или false)
* `%b`: для вывода целых чисел в двоичной системе
* `%c`: для вывода символов, представленных числовым кодом
* `%d`: для вывода целых чисел в десятичной системе
* `%o`: для вывода целых чисел в восьмеричной системе
* `%q`: для вывода символов в одинарных кавычках
* `%x`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют нижний регистр a-f
* `%X`: для вывода целых чисел в шестнадцатеричной системе, буквенные символы числа имеют верхний регистр A-F
* `%U`: для вывода символов в формате кодов Unicode, например, U+1234
* `%e`: для вывода чисел с плавающей точкой в экспоненциальном представлении, например, -1.234456e+78
* `%E`: тоже самое что `%e` но в верхнем регистре, например, -1.234456E+78
* `%f`: для вывода чисел с плавающей точкой, например, 123.456
* `%F`: то же самое, что и `%f`
* `%g`: `%e` для огромных экспонент, `%f` в противном случае
* `%G`: `%E` для огромных экспонент, `%F` в противном случае
* `%s`: для вывода строки
* `%p`: для вывода значения указателя - адреса в шестнадцатеричном представлении (указатели мы пройдем на следующих уроках)
* `%T` для вывода типа переменной

Также можно применять универсальный спецификатор `%v`, который для типа boolean аналогичен `%t`, для целочисленных типов - `%d`, для чисел с плавающей точкой - `%g`, для строк - `%s`.

Для чисел с плавающей точкой можно указать точность или количество символов в дробной части.
Для этого количество символов указывается после точки: `%.2f` - две цифры в дробной части после точки.

Например, варианты форматирования чисел с плавающей точкой:
* `%f`: точность и ширина значения по умолчанию
* `%9f`: ширина - 9 символов и точность по умолчанию (число с плавающей точкой будет занимать как минимум 9 позиций. Если ширина больше, чем требуется значению, то заполняется пробелами.)
* `%.2f`: ширина по умолчанию и точность - 2 символа
* `%9.2f`: ширина - 9 и точность - 2
* `%9.f`: ширина - 9 и точность - 0

Примеры:
```go
var a float64 = 100.123456
fmt.Printf("это число %f типа %T", a, a)
// вывод: это число 100.123456 типа float64

var a1 byte = 's'
var a2 int = 1234
fmt.Printf("%q %b", a1, a2)
// вывод: 's' 10011010010


// использование \n позволяет сделать перенос строки
var a1 string = "123"
var a2 string = "1234"
fmt.Printf("%q \n%s", a1, a2)
// вывод: 
// "123" 
// 1234
```


### Sprintf
Также есть функция `Sprintf()` которая работает как и `Printf()`, за исключением того что она ничего не печатает, а возвращает результат форматирования, рассмотрим пример:

```go
package main

import (
	"fmt"
)

func main() {
	var a float64 = 100.123456789
	result := fmt.Sprintf("%.2f", a)
	fmt.Printf("%q", result) // вывод: "100.12"
        // result будет типа string
}
```

### Литералы строк
Вначале определим разницу между литералами строк и значениями строк.
Литерал строк — это то, что мы видим в исходном коде компьютерной программы, включая кавычки.
Значение строки — это то, что мы видим в окне терминала когда вызываем функцию `fmt.Println` после запуска программы Go.

В простой программе `Hello, World!` литерал строки будет выглядеть как `"Hello, World!"`, а значением строки будет `Hello, World!` без кавычек.

Однако для некоторых значений строк могут требоваться кавычки, в частности в случае с цитатами.
Поскольку литералы строк и значения строк не эквивалентны, часто требуется добавлять в литералы строк дополнительное форматирование, чтобы значения строк отображались ожидаемым образом.

### Кавычки и обратный апостроф
В Go можно использовать обратный апостроф (``) или двойные кавычки ("), поэтому мы можем легко вставлять цитаты в строку, выделяя их двойными кавычками, в то время как сама строка выделена обратными апострофами:
```
`Sammy says, "Hello!"`
```

Также вы можете использовать обратные апострофы и заключить строку в двойные кавычки:
```
"Sammy likes the `fmt` package for formatting strings.."
```

Кроме того, комбинирование обратных апострофов и двойных кавычек позволяет контролировать отображение символов кавычек и одинарных кавычек в строках.

Важно помнить, что при использовании обратных апострофов в Go создается чистый литерал строки, а при использовании двойных кавычек — интерпретированный литерал строки.
Чтобы узнать больше о разнице между ними, ознакомьтесь с руководством [Введение в работу со строками в Go](https://www.digitalocean.com/community/tutorials/an-introduction-to-working-with-strings-in-go).

### Управляющие символы
Также для форматирования строк используются **управляющие символы**.
Управляющие символы интерпретируются кодом как имеющие особое значение.
Управляющие символы начинаются с обратной косой черты (\), за которой идет другой символ строки, в результате чего строка имеет определенный формат.

Далее приведен перечень нескольких распространенных управляющих символов, а также примеры экранирования:

| Оператор | 	Формат                                                                    | 	Пример кода       | 	Результат 
|----------|----------------------------------------------------------------------------|--------------------|------------|
| \\\\     | Обратная косая черта (это пример экранирования, а не управляющего символа) | fmt.Printf("\\\\") | \          |
| \\"      | Двойные кавычки (это пример экранирования, а не управляющего символа)      | fmt.Printf("\\"") | "          |
| \f       | подача страницы                                                            | fmt.Printf("123\f456\f789") |            |
| \v       | вертикальный таб                                                           | fmt.Printf("\vf\v") |            |
| \r | возврат каретки                                                            | fmt.Printf("\r Input ") fmt.Scan(&a) |            |
| \b | возврат (backspace U+0008)                                                 | fmt.Printf("123\b") fmt.Scan(&a) |            |
| \t | Табуляция (горизонтальный отступ)                                          | fmt.Printf("\ttest") | |
| \n | Перевод строки                                                             | fmt.Printf("test\ntest") | |

Так же есть `\a` - особый управляющий символ, необходимый для создания звука (alert).

### Многострочная печать
Многострочная печать строк делает текст более удобным для чтения.
Размещение строк в нескольких рядах делает текст более понятным и упорядоченным, позволяет форматировать его как письмо или сохранить разрывы строк в стихотворении или тексте песни.

Для создания строк, отображаемых на нескольких рядах, их нужно заключить в обратные апострофы.
Помните, что хотя при этом сохраняются символы возврата строки, создаваться будут чистые литералы строки.
```
`
This string is on
multiple lines
within three single
quotes on either side.
`
```

Если вы распечатаете этот текст, вы увидите, что символ возврата имеется в начале и в конце строки:
```
This string is on
multiple lines
within three single
quotes on either side.
```

Во избежание этого следует поместить первый ряд сразу же за обратным апострофом и закончить последний ряд обратным апострофом.
```
`This string is on
multiple lines
within three single
quotes on either side.`
```

Если вам нужно создать интерпретированный литерал строки, вы можете использовать двойные кавычки и оператор `+`, но при этом вам нужно будет самостоятельно вставлять символы разрыва строки между рядами.
```
"This string is on\n" +
"multiple lines\n" +
"within three single\n" +
"quotes on either side."
```

Хотя с обратными апострофами намного проще распечатывать и читать длинный текст, если вам требуется интерпретированный литерал строки, вам нужно использовать двойные кавычки.

### Чистые литералы строк
Что, если нам не нужно особое форматирование строк?
Например, нам может понадобиться сравнить или оценить несколько строк программного кода, где целенаправленно используется символ обратного слеша, так что мы не хотим, чтобы Go использовал этот символ как управляющий или как элемент экранирования.

Чистый литерал строки указывает Go игнорировать все форматирование строки, включая управляющие символы.

Мы можем создать чистую строку, заключив строку в обратные апострофы:
```
fmt.Println(`Sammy says,\"The balloon\'s color is red.\"`)
```
```
Sammy says,\"The balloon\'s color is red.\"
```

Построение чистой строки с помощью обратных апострофов вокруг нее позволяет сохранить в тексте символы обратного слеша и другие символы, которые используются в качестве управляющих символов.


## Массивы и срезы
### Понятие массива. Объявление и инициализация массива
**Массив** — это последовательность элементов одного типа фиксированной длины.
Объявление массива осуществляется следующим образом:
```go
var a [3]int
fmt.Println(a) // [0 0 0]
```

При объявлении массива в квадратных скобках указывается его длина (length), которая совместно с типом элементов, определяет тип самого массива, т.е. `[3]int` не может просто так взаимодействовать с `[5]int` (массивы разной длины относятся к разным типам независимо от того, что хранят значения одного типа), также как не могут без приведения взаимодействовать `int64` и `int32`.

Как мы увидели в приведенном примере, объявленный массив был при объявлении инициализирован нулевыми значениями (0 для int).
Такое поведение не является стандартным, в частности в языках C / C++ объявленный массив нулевыми значениями не заполняется.

Одновременно с объявлением массива мы можем задать значения его элементов (инициализировать его):
```go
var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]
```

В понимании первого и второго примера сложности возникнуть не должно - с этим вы уже сталкивались.
Остановимся чуть подробнее на вариантах три и четыре (массивы c и d).

Вместо явного указания длины массива мы можем указать символ многоточия (`...`) в квадратных скобках, тогда длина массива будет определена Go в зависимости от количества указанных при инициализации значений.
Несмотря на то, что такой вариант допустим, он не считается идиоматичным для Go и не рекомендуется к использованию в документации.

Четвертый же способ инициализации позволяет явно указать значение, которое должно быть присвоено элементу массива с определенным индексом.
В этом случае индексы могут появляться в любом порядке, а некоторые из них могут быть опущены; как и прежде, неуказанные значения получают нулевое значение типа элемента.

### Сравнение массивов
Поскольку мы можем последовательно сравнить все элементы массива, мы можем сравнить и сами массивы:
```go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false
```

Но при этом нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).

### Обращение к элементам массива. Индексы
Для обращения к элементам массива применяются индексы - номера элементов.
При этом нумерация элементов массива начинается с нуля, то есть первый элемент будет иметь индекс 0.
Индекс указывается в квадратных скобках.
По индексу можно получить значение элемента, либо изменить его:
```go
package main

import "fmt"

func main() {   
    var numbers [5]int = [5]int{1,2,3,4,5}    

    fmt.Println(numbers[0])     // 1  
    fmt.Println(numbers[4])     // 5   

    numbers[0] = 87   

    fmt.Println(numbers[0])     // 87
}
```

Однако в большинстве случаев нам необходимо обратиться ко всем элементам массива и выполнить с ними определенную работу.
Мы можем сделать это с помощью цикла:
```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for i := 0; i < len(a); i++ {
	fmt.Println(a[i])
	// 1
	// 2
	// 3
	// 4
	// 5
}
```

Обратите внимание, что определяя условие продолжения выполнения цикла мы использовали встроенную функцию `len()`, возвращающую длину массива.
Поскольку индексация элементов массива начинается с 0, то последний элемент массива a будет иметь индекс `len(a) - 1`.

При итерации по массиву мы можем использовать ключевое слово range, тогда цикл будет иметь следующий вид:
```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}
```

`Range` возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента.
Любой из этих объектов должен быть опущен, если мы не планируем использовать его, для этого вместо имени переменной мы можем указать символ `_`.
Кроме того, если мы хотим использовать только индекс элемента, мы можем вообще не использовать второе возвращаемое значение:
```go
a := [5]int{1, 2, 3, 4, 5}

for idx := range a {
    fmt.Println(a[idx])
}

for idx, _ := range a {
    // В этом случае следует использовать приведенный выше вариант,
    // хотя технически эти варианты работают одинаково
    fmt.Println(a[idx])
}

for _, elem := range a {
    fmt.Println(elem)
}
```

Необходимо запомнить, что в качестве второго значения `range` возвращает копию элемента массива, это может быть важно, если в цикле мы хотим изменить массив.
В этом случае мы должны обращаться к элементам массива по индексу:
```go
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for _, elem := range a {
    elem = 100
    fmt.Println(elem)

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [1 2 3 4 5]

for idx := range a {
    a[idx] = 100
    fmt.Println(a[idx])

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [100 100 100 100 100]
```

### Задание 5

<details><summary>Раскрыть</summary>
Внутри функции main (объявлять функцию не нужно) необходимо написать программу:

На первом этапе на стандартный ввод подается 10 целых положительных чисел, которые должны быть записаны в порядке ввода в массив из 10 элементов.
Тип чисел, входящих в массив, должен соответствовать минимально возможному целому беззнаковому числу.
Имя массива который вы должны сами создать workArray (условие обязательное).
Для чтения из стандартного ввода уже импортирован пакет fmt.

На втором этапе на стандартный ввод подаются еще 3 пары чисел - индексы элементов этого массива, которые требуется поменять местами (если такая пара чисел 3 и 7, значит в массиве элемент с 3 индексом нужно поменять местами с элементом, индекс которого 7).

Элементы полученного массива должны быть выведены через пробел на стандартный вывод.
Далее автоматически будет проведена проверка используемых типов, результат которой будет добавлен к вашему ответу.

Использование массива - обязательное условие!

Ответ:
```go
var workArray [10]uint8
var switchArray [6]uint8

for i := 0; i < 10; i++ {
    fmt.Scan(&workArray[i])
}
for i := 0; i < 6; i++ {
    fmt.Scan(&switchArray[i])
}

for i := 0; i < 6; i = i + 2 {
    workArray[switchArray[i]], workArray[switchArray[i+1]] = workArray[switchArray[i+1]], workArray[switchArray[i]]
}
for i := range workArray {
    fmt.Print(workArray[i], " ")
}
```

</details>


## Срезы (слайсы, slices)
**Срез** — это последовательность элементов одного типа переменной длины.

Массивы и срезы тесно связаны.
Срез — это структура данных, которая предоставляет доступ к подпоследовательности элементов базового массива.
Длину массива изменять нельзя, а вот новые элементы в срез добавлять можно, так что в некоторых языках срезами называются динамические массивы.

Срез состоит из трех компонентов: указателя, длины и емкости:
* указатель указывает на первый элемент массива, доступный через срез (который не обязательно совпадает с первым элементом массива);
* длина (length) — это количество элементов среза;
* емкость (capacity) - количество элементов между началом среза и концом базового массива.

Длина и емкость среза могут быть определены при помощи встроенных функций `len()` и `cap()` соответственно.

## С оздание среза
### Создание пустого среза
Пустой срез может быть создан аналогично созданию массива за тем исключением, что нам нет необходимости указывать длину среза, поскольку она изменяема.
При создании пустого среза мы также можем инициализировать его, явно указав элементы среза.
Давайте рассмотрим, чем различается создание массива и среза:
```go
var a []int
var b []int = []int{1, 2, 3}
c := []int{1, 2, 3}
d := []int{1: 12}

fmt.Println(a) // []
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12]
```

Варианты b и c идентичны тем, что мы уже видели при создании массива (вы можете вернуться к ранее приведенным примерам и удостовериться в этом).

В том случае, если мы просто объявляем пустой срез, он не содержит элементов (его длина равна 0, в чем мы можем удостовериться, воспользовавшись функцией `len`) - в аналогичном случае длина массива явно задается при его объявлении.

Вариант d позволяет нам создать срез и явно указать значения элементов по его индексу, Go инициализирует нужное для выполнения этой задачи число элементов нулевым значением: в примере элемент с индексом 0 равен 0, хотя мы не объявляли его явно.

На этом способы создания среза в Go не заканчиваются.
Для гибкого способа создания пустых срезов в Go существует встроенная функция make следующего вида:
```go
make([]T, length, capacity)
```

Чтобы разобраться с этой функцией нам нужно посмотреть, что происходит при создании пустого среза: Go создает массив какой-то длины.
О понятии среза мы говорили выше: указатель среза будет указывать на первый элемент созданного массива, длина среза составит 0 (если мы явно не указали элементы среза), емкость необходимого массива будет определена Go самостоятельно.

Для чего нам может потребоваться явно указать длину и емкость среза:

* для того, чтобы инициализировать нулевыми значениями элементы массива (длина среза);
* для того, чтобы выделить нужное количество памяти для хранения массива, лежащего в основе нашего среза.

```go
a := make([]int, 10, 10) // [0 0 0 0 0 0 0 0 0 0]
fmt.Println(a)
```

Функция `make` широко применяется на практике, в дальнейшем вы не раз будете использовать ее.


## Оператор среза
Оператор среза `s[i:j]` создает из последовательности s новый срез, который содержит элементы последовательности `s` с `i` по `j-1`.
При этом должно соблюдаться условие `0 <= i <= j <= cap(s)`.
В качестве исходной последовательности, из которой берутся элементы, может использоваться массив, указатель на массив или другой срез.
В итоге в полученном срезе будет `j-i` элементов.

Если значение `i` не указано, то применяется по умолчанию значение 0.
Если значение `j` не указано, то вместо него используется длина исходной последовательности `s`.
```go
initialUsers := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"} // базовый массив

users1 := initialUsers[2:6] // с 3-го по 6-й
users2 := initialUsers[:4] // с 1-го по 4-й
users3 := initialUsers[3:] // с 4-го до конца

fmt.Println(users1) // [Kate Sam Tom Paul]
fmt.Println(users2) // [Bob Alice Kate Sam]
fmt.Println(users3) // [Sam Tom Paul Mike Robert]
```

## Встроенные функции для работы со срезами
Для работы со срезами в Go предусмотрены встроенные функции `append` и `copy`.

### Функция append - добавление элементов в срез
Функция `append` позволяет добавить в срез новый элемент, выглядит она следующим образом:
```go
func append(slice []Type, elems ...Type) []Type
```

В качестве первого аргумента функция получает срез, в который необходимо добавить новые элементы, второй и последующий элементы - это элементы совместимого со срезом типа, которые необходимо добавить в срез.
Функция возвращает новый срез, содержащий ранее содержавшиеся в срезе элементы, а также новые элементы, переданные в качестве аргумента функции append.
Подробно функции будут рассмотрены в разделе 2.1. Функции.
```go
a := []int{1, 2, 3}
a = append(a, 4, 5)

fmt.Println(a) // [1 2 3 4 5]
```

### Немного сложного
Теперь самое время вернуться к вопросу о длине и емкости среза, чтобы в контексте работы функции append рассмотреть внутренне устройство срезов.
Что произойдет, если добавить в срез длины N и такой же емкости элементов больше N?
Посмотрим на примере:
```go
baseArray := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
fmt.Printf("Базовый массив: %v\n", baseArray)

baseSlice := baseArray[5:8]
fmt.Printf(
    "Срез, основанный на базовом массиве длиной %d и емкостью %d: %v\n",
    len(baseSlice),
    cap(baseSlice),
    baseSlice,
)

// Output:
// Базовый массив: [0 1 2 3 4 5 6 7 8 9]
// Срез, основанный на базовом массиве длиной 3 и емкостью 5: [5 6 7]
```

И так, мы создали массив из 10 элементов типа int, а затем создали срез на его элементы 5-7 (значения элементов в примере соответствуют их индексам).
Таким образом длина среза составляет 3, а емкость 5 (если вы не понимаете, почему получилось именно так, посмотрите еще раз в шестом шаге этого урока, из каких компонентов состоит срез).

Теперь проведем небольшую подготовительную работу.
Мы знаем, что один из компонентов среза: указатель на элемент массива, который является первым элементом среза.
Сохраним этот указатель в переменной pointer в виде строки (мы не будем его печатать, т.к. во время каждого исполнения программы он будет разным, но мы сможем использовать сохраненное значение для сравнения):
```go
pointer := fmt.Sprintf("%p", baseSlice)
```

_Напоминание_: Конструкция %p говорит, что в качестве результата должен быть возвращен адрес элемента массива, на который ссылается baseSlice.

Теперь добавим новый элемент в наш срез и посмотрим, как это повлияет на наш базовый массив:
```go
baseSlice = append(baseSlice, 10)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 4 и емкостью 5: [5 6 7 10]
// true
```

Мы видим, что изменился не только наш срез, но и базовый массив, на который ссылается срез.
Длина среза изменилась автоматически.
А теперь повторим предыдущую операцию, но добавим столько элементов, чтобы емкости среза не хватило:
```go
baseSlice = append(baseSlice, 11, 12, 13)
fmt.Printf("Массив: %v\n", baseArray)
fmt.Printf("Срез длиной %d и емкостью %d: %v\n", len(baseSlice), cap(baseSlice), baseSlice)
fmt.Println(pointer == fmt.Sprintf("%p", baseSlice))

// Output:
// Массив: [0 1 2 3 4 5 6 7 10 9]
// Срез длиной 7 и емкостью 10: [5 6 7 10 11 12 13]
// false
```

Мы видим, что базовый массив не изменился, а наш срез теперь ссылается на другой массив и имеет емкость больше длины.
Почему так произошло?
При добавлении элементов в срез Go проверяет, достаточно ли емкости среза для добавления новых элементов в срез (т.е. есть ли еще место в массиве, на котором основан срез).
Если емкости не достаточно, то создается новый срез, основанный на массиве большего объема, в который копируются все элементы из старого среза, а также добавляются новые элементы.

Этот пример наглядно демонстрирует как устроены срезы в Go: создав один раз срез на основе массива достаточной нам длины, мы можем избежать операций выделения памяти при создании нового массива и копирования элементов из одного массива в другой.

### Использование append для удаления элемента из среза
В Go отсутствует встроенная функция для удаления элемента из среза, но мы можем воспользоваться функцией append для того, чтобы создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:
```go
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

В этом примере встречается символ `...` после указания на передачу среза в качестве аргумента.
В настоящий момент можете запомнить, что такое использование многоточия означает раскрытие среза (его элементы передаются функции append как отдельные аргументы).

### Функция copy - копирование элементов среза
Сразу рассмотрим описание функции:
```go
func copy(dst, src []Type) int
// про функции мы поговорим в 2 модуле, ничего страшного если вам не очень понятно ;)
```

`Copy` принимает срез-назначение и срез источник, а возвращает число скопированных элементов:
```go
a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```

Почему мы явно указали длину создаваемого среза b?
Потому что иначе функции было бы некуда копировать.
Имей срез b длину 1, был бы скопирован 1 элемент из среза a.


## Особенности работы со срезами
Методики работы со срезами аналогичны работе с массивами с учетом тех особенностей, которые мы рассмотрели ранее.
Последовательность элементов среза также можно обойти с использованием цикла, обращаясь к ним с использованием индекса или получая значение с использованием range.

Однако существует особенность, которую ранее мы не рассматривали напрямую, поскольку сама проблема выходит за рамки рассматриваемой темы.

Рассматривая эти темы помните о том, что срез по своей сути - указатель на массив, а это влияет на его поведение при передаче в качестве аргумента в функцию:
```go
func fnA(a [3]int) {
	a[1] = 15
}

func fnB(a []int) {
	a[1] = 15
}

func main() {
	a := [3]int{1, 2, 3}
	b := []int{1, 2, 3}

	fnA(a)
	fnB(b)

	fmt.Println(a) // [1 2 3]
	fmt.Println(b) // [1 15 3]
}
```

В приведенном примере мы создали 2 функции: fnA и fnB.
Первая получает в качестве аргумента массив из 3-х элементов, вторая - срез.
Обе функции изменяют второй элемент последовательности, но мы получаем совсем разный результат, потому что fnB работала с указателем на массив и изменила непосредственно сам массив, fnA же работала с копией массива, поэтому внутри функции был изменен элемент копии массива, а базовый массив остался неизменен.

### Задания
<details><summary>Раскрыть</summary>

#### Step 14
На ввод подаются пять целых чисел, которые записываются в массив. Однако эта часть программы уже написана.
Вам нужно написать фрагмент кода, с помощью которого можно найти и вывести максимальное число в этом массиве.
```go
package main
import "fmt"

func main()  {
	array := [5]int{}
	var a int
	for i:=0; i < 5; i++{
		fmt.Scan(&a)
		array[i] = a
	}
 
 for _, v := range array {
  if v > a {
   a = v
  }
 }
 
 fmt.Println(a)
}
```

#### Step 15
Дан массив, состоящий из целых чисел. Нумерация элементов начинается с 0. Напишите программу, которая выведет элементы массива, индексы которых четны (0, 2, 4...).

**Входные данные**

Сначала задано число NN — количество элементов в массиве (1 \leq N \leq 1001≤N≤100). Далее через пробел записаны NN чисел — элементы массива. Массив состоит из целых чисел.

**Выходные данные**

Необходимо вывести все элементы массива с чётными индексами.
```go
package main
import "fmt"

func main() {
  var nElem int
  fmt.Scan(&nElem)
  nSlice := make([]int, nElem, nElem)
  
  for i := 0; i < nElem; i++ {
    fmt.Scan(&nSlice[i])
  }
  
  for i := 0; i < nElem; i=i+2 {
    fmt.Print(nSlice[i], " ")
  }
}
```

#### Step 16
Дана последовательность, состоящая из целых чисел. Напишите программу, которая подсчитывает количество положительных чисел среди элементов последовательности.

**Входные данные**

Сначала задано число NN — количество элементов в последовательности (1\leq N\leq1001≤N≤100). Далее через пробел записаны NN чисел — элементы последовательности. Последовательность состоит из целых чисел.

**Выходные данные**

Необходимо вывести единственное число - количество положительных элементов в последовательности.
```go
package main

import "fmt"

func main() {
	var iN, oN int
	fmt.Scan(&iN)
	iSlice := make([]int, iN, iN)

	for i := 0; i < iN; i++ {
		fmt.Scan(&iSlice[i])
		if iSlice[i] > 0 {
			oN++
		}
	}
	fmt.Println(oN)
}
```

</details>

## 1.13 Решение задач
<details><summary>Раскрыть</summary>

### Step 1
Дано трехзначное число. Найдите сумму его цифр. 

**Формат входных данных**
На вход дается трехзначное число.

**Формат выходных данных**
Выведите одно целое число - сумму цифр введенного числа.

```go
package main
import "fmt"

func main() {
	var iNum int
	var oSlice [3]int

	fmt.Scan(&iNum)

	oSlice[0] = iNum / 100
	oSlice[2] = iNum % 10
	oSlice[1] = (iNum - oSlice[0] * 100) / 10
	
	fmt.Print(oSlice[0] + oSlice[1] + oSlice[2])
}
```

### Step 2
Дано трехзначное число. Переверните его, а затем выведите. 

**Формат входных данных**
На вход дается трехзначное число, не оканчивающееся на ноль.

**Формат выходных данных**
Выведите перевернутое число.

```go
package main
import "fmt"

func main() {
	var iNum int
	var oSlice [3]int

	fmt.Scan(&iNum)

	oSlice[0] = iNum / 100
	oSlice[2] = iNum % 10
	oSlice[1] = (iNum - oSlice[0] * 100) / 10

	oSlice[0], oSlice[2] = oSlice[2], oSlice[0]
	
	fmt.Printf("%d%d%d", oSlice[0], oSlice[1], oSlice[2])
}
```

### Step 3
Идёт k-я секунда суток. Определите, сколько целых часов h и целых минут m прошло с начала суток. Например, если

k=13257=3*3600+40*60+57,

то h=3 и m=40.

**Входные данные**

На вход программе подается целое число k (0 < k < 86399).

**Выходные данные**

Выведите на экран фразу:

`It is ... hours ... minutes.`

Вместо многоточий программа должна выводить значения h и m, отделяя их от слов ровно одним пробелом.

```go
package main
import "fmt"

func main() {
	var iNum int
	var oSlice [2]int

	fmt.Scan(&iNum)

	oSlice[0] = iNum / 3600
	oSlice[1] = (iNum - oSlice[0] * 3600) / 60

	fmt.Printf("It is %d hours %d minutes.", oSlice[0], oSlice[1])
}
```

### Step 4
Заданы три числа - a, b, c (a < b < c)a,b,c(a<b<c) - длины сторон треугольника. Нужно проверить, является ли треугольник прямоугольным. Если является, вывести "Прямоугольный". Иначе вывести "Непрямоугольный"

**Sample Input:**

`6 8 10`

**Sample Output:**

`Прямоугольный`

```go
package main
import "fmt"

func main() {
	var iSlice [3]int
	var maxKey int

	for k := range iSlice {
		fmt.Scan(&iSlice[k])
		if iSlice[k] > iSlice[maxKey] {
			maxKey = k
		}
	}

	iSlice[0], iSlice[maxKey] = iSlice[maxKey], iSlice[0]
	if (iSlice[0] * iSlice[0] - iSlice[1] * iSlice[1] - iSlice[2] * iSlice[2]) == 0 {
		fmt.Println("Прямоугольный")
	} else {
		fmt.Println("Непрямоугольный")
	}
}
```

### Step 5
**Входные данные**

Даны три натуральных числа a, b, c.
Определите, существует ли треугольник с такими сторонами.

**Выходные данные**

Если треугольник существует, выведите строку "Существует", иначе выведите строку "Не существует".
Строку выводите без кавычек.

```go
package main
import "fmt"

func main() {
	var iSlice [3]int

	for k := range iSlice {
		fmt.Scan(&iSlice[k])
	}

	if (iSlice[0] + iSlice[1] > iSlice[2]) && (iSlice[0] + iSlice[2] > iSlice[1]) && (iSlice[1] + iSlice[2] > iSlice[0]) {
		fmt.Print("Существует")
	} else {
		fmt.Print("Не существует")
	}
}
```

### Step 6
Даны два числа.
Найти их среднее арифметическое.

**Формат входных данных**

На вход дается два целых положительных числа a и b.

**Формат выходных данных**

Программа должна вывести среднее арифметическое чисел a и b (ответ может быть целым числом или дробным)
```go
package main
import "fmt"

func main() {
	var iSlice [2]int

	for i := range iSlice {
		fmt.Scan(&iSlice[i])
	}

	fmt.Printf("%v", float64(iSlice[0] + iSlice[1]) / 2)
}
```

### Step 7
По данным числам, определите количество чисел, которые равны нулю.  

**Входные данные**

Вводится натуральное число N, а затем N чисел.

**Выходные данные**

Выведите количество чисел, которые равны нулю.
```go
package main
import "fmt"

func main() {
	var iN, oN, temp int

	fmt.Scan(&iN)

	for i := 0; i < iN; i++ {
		fmt.Scan(&temp)
		if temp == 0 {
			oN++
		}
	}

	fmt.Print(oN)
}
```

### Step 8
Найдите количество минимальных элементов в последовательности.

**Входные данные**

Вводится натуральное число N, а затем N целых чисел последовательности.

**Выходные данные**

Выведите количество минимальных элементов последовательности.
```go
package main
import "fmt"

func main() {
	var iN, oN, minN, temp int

	fmt.Scan(&iN)

	for i := 0; i < iN; i++ {
		fmt.Scan(&temp)
		if (temp < minN) || (i == 0) {
			minN = temp
			oN = 1
		} else if temp == minN {
			oN++
		}
	}

	fmt.Print(oN)
}
```

### Step 9
Цифровой корень натурального числа — это цифра, полученная в результате итеративного процесса суммирования цифр, на каждой итерации которого для подсчета суммы цифр берут результат, полученный на предыдущей итерации.
Этот процесс повторяется до тех пор, пока не будет получена одна цифра.

Например цифровой корень 65536 это 7 , потому что 6+5+5+3+6=25 и 2+5=7 . 

По данному числу определите его цифровой корень.

**Входные данные**

Вводится одно натуральное число n, не превышающее 10^7

**Выходные данные**

Вывести цифровой корень числа n.
```go
package main
import "fmt"

func main() {
	var iN, oN int
	var temp string

	fmt.Scan(&iN)
	temp = fmt.Sprint(iN)

	for ; len(temp) != 1; {
		oN = 0
		for _, v := range temp {
			oN = oN + int(v - '0')
		}
		temp = fmt.Sprint(oN)
	}

	fmt.Println(oN)
}
```

### Step 10
Самое большое число, кратное 7
Найдите самое большее число на отрезке от a до b, кратное 7 .

**Входные данные**

Вводится два целых числа a и b (a≤b).

**Выходные данные**

Найдите самое большее число на отрезке от a до b (отрезок включает в себя числа a и b), кратное 7 , или выведите "NO" - если таковых нет.
```go
package main
import "fmt"

func main() {
	var oN int
	var iArray [2]int
    var oSwitch bool

	for k := range iArray {
		fmt.Scan(&iArray[k])
	}
	
	for i := iArray[1]; i >= iArray[0]; i-- {
        if i % 7 == 0 {
			oN = i
            oSwitch = true
			break
		}
	}

	if !oSwitch {
		fmt.Println("NO")
	} else {
		fmt.Println(oN)
	}
}
```

### Step 11
По данному числу n закончите фразу "На лугу пасется..." одним из возможных продолжений: "n коров", "n корова", "n коровы", правильно склоняя слово "корова".

**Входные данные**

Дано число n (0<n<100).

**Выходные данные**

Программа должна вывести введенное число n и одно из слов (на латинице): korov, korova или korovy, например, 1 korova, 2 korovy, 5 korov.
Между числом и словом должен стоять ровно один пробел.
```go
package main
import "fmt"

func main() {
	var iN int

	fmt.Scan(&iN)

	switch {
	case iN / 10 == 1:
		fmt.Printf("%d korov", iN)
	case iN % 10 == 1:
		fmt.Printf("%d korova", iN)
	case (iN % 10 > 1) && (iN % 10 < 5):
		fmt.Printf("%d korovy", iN)
	default:
		fmt.Printf("%d korov", iN)
	}
}
```

### Step 12
По данному числу N распечатайте все целые значения степени двойки, не превосходящие N, в порядке возрастания.

**Входные данные**

Вводится натуральное число.

**Выходные данные**

Выведите ответ на задачу.
```go
package main

import (
	"fmt"
	"math"
)

func main() {
	var iN, oN, base int

	fmt.Scan(&iN)
	oN = 1
	base = 2

	for i := 1; oN <= iN; i++ {
		fmt.Print(oN, " ")
		oN = int(math.Pow(float64(base), float64(i)))
	}
}
```

### Step 13
Дано натуральное число A > 1.
Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число n, что φn=A.
Если А не является числом Фибоначчи, выведите число -1.

**Входные данные**

Вводится натуральное число.

**Выходные данные**

Выведите ответ на задачу.
```go
package main

import "fmt"

func main() {
	var iN int
	var iFibo [2]int = [2]int{1, 1}

	fmt.Scan(&iN)
	
	for i := 2; ; i++ {
		iFibo[0], iFibo[1] = iFibo[1], iFibo[0] + iFibo[1]

		if iN == iFibo[1] {
			fmt.Println(i+1)
			break
		} else if (iN > iFibo[0]) && (iN < iFibo[1]) {
			fmt.Println(-1)
			break
		}
	}
}
```

### Step 14
Дано натуральное число N. Выведите его представление в двоичном виде.

**Входные данные**


Задано единственное число N

**Выходные данные**

Необходимо вывести требуемое представление числа N.
```go
package main

import "fmt"

func main() {
	var iN int

	fmt.Scan(&iN)
	
	fmt.Printf("%b", iN)
}
```

### Step 15
Из натурального числа удалить заданную цифру.

**Входные данные**

Вводятся натуральное число и цифра, которую нужно удалить.

**Выходные данные**

Вывести число без заданных цифр.
```go
package main

import "fmt"

func main() {
	var iN, iDel, oStr string
	
	fmt.Scan(&iN)
	fmt.Scan(&iDel)

	for i := 0; i < len(iN); i++ {
		if string(iN[i]) != iDel {
			oStr += string(iN[i])
		}
	}
	
	fmt.Println(oStr)
}
```

</details>


# 2. Функции, структуры, указатели и другое
## 2.1 Функции
**Функция** представляет блок операторов, которые все вместе выполняют какую-то определенную задачу. С помощью функций можно многократно вызывать ее блок операторов как единое целое в других частях программы.

Функция объявляется следующим образом:
```go
func имя_функции (список_параметров) (типы_возвращаемых_значений) {
    выполняемые_операторы
}
```

Пример функции:
```go
func main() {
   hello()
}

func hello() {
    fmt.Println("Hello World")
}
```

**Важно!** Открывающая фигурная скобка должна располагаться на той же строке, что и объявление функции, иначе вы получите ошибку. Это сделано для единого стиля кода.

**Напоминаем**, краткое объявление переменных (a := 5) работает только внутри функций.

 

Полезности: если вы установили Go на компьютер, то можете использовать командную строку для изучения документации по той или иной стандартной функции. Например, если мы хотим узнать подробности о функции Println() мы можем ввести команду:
```
go doc fmt.Println
```

или
```
go doc fmt Println
```

Если вы хотите более подробно узнать о работе команды doc, можете ввести команду:
```
go help doc
```

### Параметры функции
Через параметры функция получает входные данные.
Параметры указываются в скобках после имени функции.
Для каждого параметра указывается имя и тип (как для переменной).
Друг от друга параметры разделяются запятыми.
При вызове функции необходимо передать значения для всех ее параметров.
Например, мы хотим использовать функцию, которая складывает два любых числа:
```go
package main
import "fmt"
 
func main() {
    add(4, 5)   // x + y = 9
    add(20, 6)  // x + y = 26
}
 
func add(x int, y int){
    var z = x + y
    fmt.Println("x + y = ", z)
}
```

Функция `add` имеет два параметра: x и y. Оба параметра представляют тип `int`, то есть целые числа.
В самой функции определяется переменная, которая хранит сумму этих чисел.
И затем сумма чисел выводится на консоль.

В функции `main` вызывается функция `add`.
Так как функция принимает два параметра, то при вызове ей необходимо передать значения для этих параметров или два аргумента.
Причем эти значения должны соответствовать параметрам по типу.
То есть если параметр представляет тип `int`, то ему необходимо передать число.

Значения передаются по позиции. То есть первое значение получит первый параметр, второе значение - второй параметр и так далее.
В итоге мы получим следующий консольный вывод:
```
x + y = 9
x + y = 26
```

Если несколько параметров подряд имеют один и тот же тип, то мы можем указать тип только для последнего параметра, а предыдущие параметры также будут представлять этот тип:
```go
package main
import "fmt"
 
func main() {
    add(1, 2, 3.4, 5.6, 1.2)
}
func add(x, y int, a, b, c float32){
    var z = x + y
    var d = a + b + c
    fmt.Println("x + y = ", z)
    fmt.Println("a + b + c = ", d)
}
```

В качестве аргументов при вызове функции можно передавать и значения переменных, результаты операций или других функций, но при этом следует учитывать, что если аргументы в функцию передаются по значению то они копируются:
```go
package main
import "fmt"
 
func main() {
    var a = 8
    fmt.Println("a before: ", a)
    increment(a)
    fmt.Println("a after: ", a)
}
func increment(x int){
 
    fmt.Println("x before: ", x)
    x = x + 20
    fmt.Println("x after: ", x)
}
```

Вывод:
```
a before: 8
x before: 8
x after: 28
a after: 8
```

В данном случае в качестве аргумента в функцию `increment` передается значение переменной a.
Параметр x получает это значение, и оно увеличивается на 20.
Однако несмотря на то, что значение параметра x увеличилось, значение переменной a никак не изменилось.
Потому что при вызове функции передается копия значения переменной.


### Возвращение результата из функции
Функции могут возвращать результат.
Для этого нужно после списка параметров функции указать тип возвращаемого результата.
А в теле функции использовать оператор `return`, после которого указывается возвращаемое значение:
```go
func имя_функции (список_параметров) тип_возвращаемого_значения {
    выполняемые_операторы
    return возвращаемое_значение
}
```

Например, мы хотим возвратить из функции сумму двух чисел:
```go
package main
import "fmt"
 
func main() {
    var a = add(4, 5)   // 9
    var b = add(20, 6)  // 26
    fmt.Println(a)
    fmt.Println(b)
}
 
func add(x, y int) int {
    return x + y
}
```

Функция add возвращает значение типа `int`, поэтому данный тип указан после списка параметров.
В самой функции после оператора `return` указывается возвращаемое значение.
При этом данное значение может быть значением переменной, литералом, либо же, как в данном случае, результатом операции или вызова функции.
То есть выражение x + y определяет возвращаемое значение.

Поскольку функция возвращает значение, то при вызове функции мы можем получить это значение и передать его переменной:
```
var a = add(4, 5)   // 9
var b = add(20, 6)  // 26
```


### Возвращение нескольких значений
В Go функция может возвращать сразу несколько значений.
В этом случае после списка параметров указывается в скобках список типов возвращаемых значений.
А после оператора return располагаются через запятую все возвращаемые значения:
```go
package main
import "fmt"
 
func main() {
    var age, name = add(4, 5, "Tom", "Simpson")
    fmt.Println(age)    // 9
    fmt.Println(name)   // Tom Simpson
}
 
func add(x, y int, firstName, lastName string) (int , string) {
    var z int = x + y
    var fullName = firstName + " " + lastName
    return z, fullName
}
```

Функция `add` принимает четыре параметра: два числа и две строки.
Возвращает число (значение типа `int`) и строку.
Возвращаемые значения указаны после оператора `return`.

Поскольку функция теперь возвращает два значения, то при вызове этой функции мы можем присвоить ее результат двум переменным:
```go
var age, name = add(4, 5, "Tom", "Simpson")
```

Первое возвращаемое значение передается первой переменной age, а второе значение передается второй переменной name.

Альтернативный способ передачи переменным результатов функции:
```go
age, name := add(4, 5, "Tom", "Simpson")
```

### Игнорирование возвращаемых значений
Go позволяет проигнорировать все или определенные возвращаемые функцией значения, если мы не будем использовать их в дальнейшем.
Для этого нам необходимо не присваивать им имена вообще либо заменить имя символом `_`.
Рассмотрим это на примере:
```go
func fn() (int, error) {
	// Какая-то полезная работа
	// ...
	return 0, nil
}

func ExampleIgnor() {
	fn()

	i, _ := fn()
	fmt.Println(i)

	_, err := fn()
	if err == nil {
		fmt.Println("Ошибок нет")
	}

	// Output:
	// 0
	// Ошибок нет
}
```

Здесь мы создали функцию-заглушку, возвращающую 2 значения: число и ошибка.

В первом примере мы проигнорировали оба возвращаемых значения, выполнив полезную работу функции (так мы часто делаем, когда используем функцию `fmt.Print` - игнорируя возвращаемые ею значения).

Во втором примере мы проигнорировали сообщение об ошибке (не делайте так), а в третьем - только проверили, возвратила ли функция ошибку, проигнорировав возвращаемое число.


### Функции с переменным количеством параметров (аргументов)
В завершении данной темы необходимо рассмотреть возможность передачи в функцию переменного количества аргументов.
Для примера рассмотрим как выглядит функция Print из пакета fmt стандартной библиотеки:
```go
func Print(a ...interface{}) (n int, err error) // interface мы рассмотрим в 3 модуле, это лишь для примера
```

Мы видим, что функция принимает аргумент `a` типа `interface{}`, но перед указанием типа имеется знак многоточия (`…`).
Символ многоточия перед указанием типа указывает, что в функцию можно передать произвольное количество параметров указанного типа.
Посмотрим, как это выглядит на практике:
```go
func ExamplePrint() {
	fmt.Print(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}
```

Функция получила 5 аргументов произвольного типа (в примере это числа) и напечатала их все.
Разберемся, как работает данная функция.

Аргумент с именем `a` воспринимается функцией как срез элементов заданного типа `interface{}`, внутри функция работает с элементами этого среза соответствующим образом.
Вот так эта функция могла бы выглядеть (под капотом реализация функции гораздо сложнее, но мы рассмотрим лишь необходимую нам часть функционала):
```go
func myPrint(a ...interface{}) {
	for _, elem := range a {
		fmt.Printf("%d ", elem)
	}
}

func ExampleMyPrint() {
	myPrint(1, 2, 3, 4, 5)

	// Output:
	// 1 2 3 4 5
}
```

Для примера мы реализовали функцию-обертку над `fmt.Printf`, чтобы показать, как обрабатывается переменное число аргументов.

Необходимо запомнить, что если функция принимает определенные аргументы и еще произвольное число аргументов определенного типа, то при объявлении функции эти «переменные» аргументы указываются в самом конце.
Для примера:
```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
```

Эта функция принимает обязательный аргумент тип `io.Writer` и произвольное число аргументов типа `interface{}`.

В рамках данного урока вы неоднократно сталкивались с таким типом как `interface{}`, данная тема будет подробно рассмотрена в 3 модуле данного курса, пока же вы можете запомнить что использование этого типа (пустого интерфейса) означает, что функция может получить аргумент любого типа: строку, число, структуру и т.д.

#### Небольшое дополнение по использованию многоточия (`...`)
Как мы выяснили, знак многоточия слева от указания на тип передаваемого значения свидетельствует о возможности передать в функцию неопределенное количество аргументов указанного типа, внутри функции переданные аргументы будут обработаны как срез указанного в объявлении функции типа.

Однако язык Go предусматривает обратный способ использования многоточия - разворачивание (раскрытие) среза путем указания справа от среза знака многоточия.
Приведу 2 примера:
```go
func ExampleExpandSlice1() {
	s := []interface{}{1, 2, 3, 4, 5}

	fmt.Println(s)
	fmt.Println(s...)

	// Output:
	// [1 2 3 4 5]
	// 1 2 3 4 5
}
```

В первом примере мы создали срез типа `[]interface`, а затем напечатали его в виде среза и в виде отдельных значений, входящих в него.

Важный вопрос, почему мы использовали тип `[]interface` вместо типа `[]int`?
Это связано с механикой приведения типов в Go, в силу которой `[]int` не является `[]interface`. Но т.к. интерфейсы будут рассмотрены только в следующем модуле, рассмотрим эту проблему в дальнейшем.

В следующем примере мы создаем 2 среза типа `[]int`, а затем используем встроенную функцию append для того, чтобы в элементы первого среза добавить элементы второго среза.
Сигнатура функции приведена в самом примере в виде комментария: первый аргумент - срез указанного типа, далее следует неопределенное число аргументов указанного типа.

Использовав разворачивание среза `s2` мы передадим в функцию сразу все его элементы.
```go
func ExampleExpandSlice2() {
	s1 := []int{1, 2, 3, 4, 5}
	s2 := []int{6, 7, 8, 9, 10}

	// append(slice []Type, elems ...Type) []Type

	// s1 = append(s1, s2) не сработает, т.к. второй и
	// последующие аргументы в нашем случае должны быть int

	s1 = append(s1, s2...)
	fmt.Println(s1)

	// Output:
	// [1 2 3 4 5 6 7 8 9 10]
}
```

### Задание
<details><summary>Раскрыть</summary>

Напишите функцию sumInt, принимающую переменное количество аргументов типа int, и возвращающую количество полученных функцией аргументов и их сумму.
Пакет "fmt" уже импортирован, функция и пакет main объявлены.

Пример вызова вашей функции:
```go
a, b := sumInt(1, 0)
fmt.Println(a, b)
```

**Результат**: 2, 1
```go
func sumInt(iN ...int) (oCount, oSum int) {
    for _, v := range iN {
		oSum += v
		oCount++
	}

	return
}
```

</details>


### Область видимости
Объявляя переменную, мы связываем ее имя с отражающей ее сущностью (числом, строкой, структурой).
Область видимости является частью исходного кода, в которой использование объявленного имени ссылается на сущность из этого объявления.

В Go область видимости определяется лексическими блоками, к которым относятся:
* синтаксические блоки (последовательность инструкций, заключенных в фигурные скобки);
* прочие блоки, которые явно не охватываются фигурными скобками в исходном тексте, но имеют схожее поведение: всеобщий блок, блок для каждого пакета, блок для каждого файла.

Имя, объявленное внутри синтаксического блока, невидимо вне блока, приведем пример:
```go
package main

import "fmt"

func scope() {
	v := 1
	fmt.Print(v)
}

func main() {
    /*
     * Если мы не станем рассматривать в данном случае вопрос о времени жизни переменной,
     * а сконцентрируемся только на области видимости, то можем констатировать, что из
     * функции main мы не можем получить доступа к переменной v, объявленной в функции
     * scope.
     */
	scope()
	fmt.Print(v) // ошибка компиляции
}
```

Программа может содержать несколько объявлений одного и того же имени при условии, что все объявления находятся в различных лексических блоках.
Например, можно объявить локальную переменную с тем же именем, что и переменная уровня пакета.
Компилятор же, встретив ссылку на имя, ищет объявление, начиная с наиболее глубоко вложенного внутреннего лексического блока и продолжая до всеобщего блока.
Если компилятор не обнаруживает объявление, он сообщает об ошибке "необъявленное имя".
Если имя объявлено и в наружном, и во внутреннем блоках, первым будет обнаружено внутреннее объявление.
В этом случае говорят, что внутреннее объявление затеняет внешнее:
```go
func ExampleScope1() {
	var v int = 1

	{
		/*
		 * Здесь переменная из внешнего лексического блока затеняется
		 * переменной внутреннего лексического блока
		 */
		var v string = "2"
		fmt.Println(v)
	}

	fmt.Println(v)

	/*
	 * В примере мы объявили в отдельных лексических блоках переменные с одним именем и
	 * разными типами, а затем напечатали значения этих переменных.
	 */

	// Output:
	// 2
	// 1
}
```

Как упоминалось выше, не все лексические блоки соответствуют последовательностям операторов, помещенным в фигурные скобки, некоторые из них просто подразумеваются.
С областью видимости в пределах файла, пакета, глобальной областью видимости все более или менее просто, но этим рассматриваемая тема не ограничивается.

Цикл `for` создает два лексических блока: явный блок для тела цикла и неявный блок, который дополнительно охватывает переменные, объявленные в инициализации цикла.
```go
func ExampleScope2() {
	var i string = "Строка"

	/*
	 * Переменная i объявляется вне фигурных скобок, тем не менее это
	 * отдельная область видимости, к которой имеет доступ вторая область видимости,
	 * которая уже заключена в фигурные скобки
	 */
	for i := 0; i < 1; i++ {
		fmt.Println(i)
	}

	/*
	 * Аналогично примеру выше мы объявляем переменную i в области видимости
	 * вне фигурных скобок, а в теле цикла (отдельная область видимости) -
	 * затеняем переменную i
	 */
	for i := 0; i < 1; i++ {
		i := true
		fmt.Println(i)
	}

	fmt.Println(i)

	// Output:
	// 0
	// true
	// Строка
}
```

Аналогично конструкции цикла for такие неявные области видимости создаются конструкциями `if`, `switch` и `select`.


## Пакеты
Весь код в языке Go организуется в пакеты.
Пакеты представляют удобную организацию разделения кода на отдельные части или модули.
Модульность позволяет определять один раз пакет с нужной функциональностью и потом использовать его многократно в различных программах.

Код пакета располагается в одном или нескольких файлах с расширением go.
Для определения пакета применяется ключевое слово `package`.
Например:
```go
package main

import "fmt"
 
func main() {
     
    fmt.Println("Hello Go")
}
```

В данном случае пакет называется `main`.
Определение пакета должно идти в начале файла.

Есть два типа пакетов: **исполняемые (executable)** и **библиотеки (reusable)**.
Для создания исполняемых файлов пакет должен иметь имя `main`.
Все остальные пакеты не являются исполняемыми.
При этом пакет `main` должен содержать функцию `main`, которая является входной точкой в приложение.

### Импорт пакетов
Если уже есть готовые пакеты с нужной нам функциональностью, которую мы хотим использовать, то для их использования мы можем их импортировать в программу с помощью оператора `import`.
Например, в примере выше задействуется функциональность вывода сообщения на консоль с помощью функции `Println`, которая определена в пакете `fmt`.
Соответственно чтобы использовать эту функцию, необходимо импортировать пакет `fmt`:
```go
import "fmt"
```

Нередко программы подключают сразу несколько внешних пакетов.
В этом случае можно последовательно импортировать каждый пакет:
```go
package main

import "fmt"
import "math"
 
func main() {
     
    fmt.Println(math.Sqrt(16))  // 4
}
```

В данном случае подключается встроенный пакет `math`, который содержит функцию `Sqrt()`, возвращающую квадратный корень числа.

Либо чтобы сократить определение импорта пакетов можно заключить все пакеты в скобки:
```go
package main

import (
    "fmt"
    "math"
)
 
func main() {
     
    fmt.Println(math.Sqrt(16))
}
```

Подобным образом мы можем импортировать как встроенные пакеты, так и свои собственные.
Полный список встроенных пакетов в Go можно найти по адресу [https://golang.org/pkg/](https://golang.org/pkg/).

Если вы знакомы с другими языками программирования, вам возможно знакомы конструкции типа таких:
```
using namespace std  // C++
from math import *   # python
```

Они позволяют использовать функции из импортируемых пакетов без указания имени самого пакета.
Хотя это считается не самой лучшей практикой, тем не менее в Go есть аналогичный способ импорта - импорт с точкой:
```go
package main

import . "fmt"

func main() {
    Println("Hello, Go!")
}
```

или же:
```go
package main

import (
    . "fmt"
)

func main() {
    Println("Hello, Go!")
}
```

Импорт с точкой добавляет все экспортируемые поля пакета в текущий скоуп (точнее говоря область видимости файла).
И теперь вы можете работать с полями импортированного пакет так, как будто они у вас в пакете.

### Импорт c синонимом
Так же мы можем присвоить импорту "синоним" - то есть заменить `fmt` на другое слово при использовании этого пакета.
```go
package main

import custom "fmt"

func main() {
	custom.Println("Hello!")
}
```

Пакеты импортируют, задавая синонимы, в нескольких случаях:
* Имя импортируемого пакета неудобное/некрасивое/… и хочется использовать другое;
* Имя импортируемого пересекается с именем другого пакета;
* Хочется бесшовно подменить пакет — интерфейсы пакетов должны совпадать.

В Go нет стандартного ООП как в C++/Java/C# и других языках.
Поэтому и классов здесь нет, но есть пакеты.
Большие программы принято разделять на пакеты, чтобы упростить её чтение.

Создадим в проекте два файла: один - `main.go`, другой - `main2.go`.
Но оба файла лежат в одном пакете, потому что мы прописали package `main`.
Поэтому мы без импорта можем вызывать функции из другого файла.
![img](./assets/packets_import.png)

Для запуска программы выше необходимо указать все файлы пакета main через пробел:
```bash
go run main.go main2.go
```

###  Модули
С ростом проекта вам захочется обособить логически завершенную часть кода, скрыть внутреннюю реализацию отдельных функций и методов, локальные константы и пр., оставив "торчать наружу" лишь публичные интерфейсы, структуры, функции и переменные.
Тогда вы можете использовать несколько пакетов в одном проекте.
Запомните, что приватные и публичные объекты отличаются тем, что имена публичных объектов должны начинаться с большой буквы!
![img](./assets/packets_import_2.png)

А далее становится сложно следить за зависимостями такого проекта, особенно сложно тем разработчикам, которые используют уже ваш проект.
Что делать? В настоящее время правильным способом организации даже небольших проектов является модуль.

Модуль, это коллекция пакетов, распространяемых вместе (возможно это компоненты одной программы или одной библиотеки).
В корне модуля находится файл `go.mod`, в котором записано имя модуля, версия Go, в которой он был написан, а также пути ко всем импортированным в модуле пакетам.
Модуль включает в себя пакеты, находящиеся ниже корневой директории даже в том случае, если сами эти пакеты содержат файл `go.mod`.
Посмотрите на предыдущий скриншот или в импортированный вами модуль проекта - в нем присутствуют файлы `go.mod` и `go.sum`, это говорит о том, что проект распространяется как модуль.

Ранее Go предполагал, что пользователь создаст определенную структуру директорий, которую будет использовать для разработки всех своих проектов:
```
go/
├── bin
├── pkg
└── src
```

На директорию go указывала переменная окружения GOPATH:
* для Windows это обычно `C:\Users\имя_пользователя\go`
* для GNU/Linux это обычно `/home/имя_пользователя/go`

Проекты, которые располагались не в директории go/src имели проблемы при компиляции.
Модули изменили положение дел.
Вместе с тем, если вы не разработчик огромной корпорации, разумно придерживаться определенных правил по размещению кода в приведенных директориях.
Кроме того, разработчики go рекомендуют размещать проект таким образом, как будто вы публикуете его во внешнем репозитории (даже если вы так не делаете).

Если вы хотите сделать все правильно, то алгоритм ваших действий  примерно таков:

Создать проект в папке /src/ваш_любой_ник/имя_проекта.
Если у вас уже есть github аккаунт то можете создать проект так: /src/github.com/username/имя_проекта.

**Примечание**:
github.com и username всего-лишь формальности, это не обязательно должно совпадать с вашим аккаунтом, на github ничего автоматически не отправится.
Код вы храните только локально. 

Модуль инициализируется следующим образом:
```bash
// name не обязателен
go mod init <name> // инициализировать новый модуль в текущем каталоге

// другие команды
go mod download    скачать модули в локальный кеш
go mod edit        редактировать go.mod из инструментов или скриптов
go mod graph       напечатать граф требований модуля
go mod tidy        добавить отсутствующие и удалить неиспользуемые модули
go mod vendor      делает вендорную копию зависимостей
go mod verify      проверить зависимости ожидаемого содержания
go mod why         объяснять, зачем нужны пакеты или модули
```

**Примечание!**
Тема организации кода не проста, т.к. каждый использует свою операционную систему, переменные окружения, организацию рабочего кода.
Поэтому обязательно прочитайте [эту статью](https://golang.org/doc/code.html) и попробуйте произвести все действия самостоятельно.
Если возникнут какие-то проблемы, мы ответим на них в комментариях.

Кроме того, для примера мы предлагаем вам скачать тестовый модуль из репозиория на GitHub, сделать это можно командой:
```bash
go get -u github.com/semyon-dev/stepik-go
```

## Указатели
**Указатель** - значение, которое указывает на адрес другой переменной.
Рассмотрим это на примере:
```go
func main() {
        a := 200
        b := &a
        *b++
        fmt.Println(a)
}
```

В этом примере мы инициализируем переменную а и ссылающуюся на неё переменную b, мы не знаем, где она лежит, однако компилятор об этом позаботится.
Оператор `&` (взятие адреса) говорит о том, что в переменную b записывается не значение переменной a, а её адрес в памяти.
Переменная b здесь является указателем. 

`*` является признаком указателя, то есть Вы работаете не с переменной b, а с переменной, на которую ссылается указатель

Иначе можно записать так:
```go
a := 200
var b *int = &a
```
`*int` - значит переменная указывает на другую переменную типа `int`

Третья строчка - концентрация всей темы.
В ней мы увеличиваем значение переменной а, т.к переменная b ссылается на адрес переменной a.

Другой способ получить указатель — использовать встроенную функцию `new`:
```go
func one(xPtr *int) {
    *xPtr = 1
}
func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr) // x is 1
}
```

Функция new принимает аргументом тип, выделяет для него память и возвращает указатель на эту память.

В некоторых языках программирования есть существенная разница между использованием `new` и `&`, и в них нужно удалять всё, что было создано с помощью `new`.
Go не такой - Go хороший.
Go — язык с автоматической сборкой мусора.
Это означает, что область памяти очищается автоматически, когда на неё не остаётся ссылок.

Указатели редко используются в Go для встроенных типов, но они будут часто фигурировать в следующей главе (они чрезвычайно полезны при работе со структурами).

Так же рекомендуем дополнительно прочитать интересную статью по теме [https://habr.com/en/post/339192/](https://habr.com/en/post/339192/)

Также мы можем создать указатель на указатель.
```go
package main

import "fmt"

func main() {
   a := 200
   b := &a
   *b++
   c := &b
   **c++ // указатель на указатель
   fmt.Println(a)
}
```
```
Вывод: 202
``` 

## Структуры
Несмотря на то, что вполне можно писать программы на Go, используя только встроенные типы, в какой-то момент это станет очень утомительным занятием.
Вот пример — программа, которая взаимодействует с фигурами:
```go
package main

import ("fmt"; "math")

func distance(x1, y1, x2, y2 float64) float64 {
    a := x2 - x1
    b := y2 - y1
    return math.Sqrt(a*a + b*b)
}
func rectangleArea(x1, y1, x2, y2 float64) float64 {
    l := distance(x1, y1, x1, y2)
    w := distance(x1, y1, x2, y1)
    return l * w
}
func circleArea(x, y, r float64) float64 {
    return math.Pi * r * r
}
func main() {
    var rx1, ry1 float64 = 0, 0
    var rx2, ry2 float64 = 10, 10
    var cx, cy, cr float64 = 0, 0, 5

    fmt.Println(rectangleArea(rx1, ry1, rx2, ry2))
    fmt.Println(circleArea(cx, cy, cr))
}
```

Отслеживание всех переменных мешает нам понять, что делает программа, и наверняка приведет к ошибкам.

С помощью структур эту программу можно сделать гораздо лучше.
Структура — это тип, содержащий именованные поля.
Например, мы можем представить круг таким образом:
```go
type Circle struct {
    x float64
    y float64
    r float64
}
```

Ключевое слово type вводит новый тип.
За ним следует имя нового типа `Circle` и ключевое слово `struct`, которое говорит, что мы определяем структуру и список полей внутри фигурных скобок.
Каждое поле имеет имя и тип.
Как и с функциями, мы можем объединять поля одного типа:
```go
type Circle struct {
    x, y, r float64
}
```

### Инициализация
Мы можем создать экземпляр нового типа Circle несколькими способами:
```go
var c Circle
// или
c := Circle{}
```

Подобно другим типам данных, будет создана локальная переменная типа `Circle`, чьи поля по умолчанию будут равны нулю (0 для `int`, 0.0 для `float`, "" для `string`, `nil` для **указателей**, …).
Также, для создания экземпляра можно использовать функцию `new`.
```go
c := new(Circle)
```

Это выделит память для всех полей, присвоит каждому из них нулевое значение и вернет указатель (`*Circle`).
Часто, при создании структуры мы хотим присвоить полям структуры какие-нибудь значения.
Существует два способа сделать это.
1. Первый способ:
   ```go
   c := Circle{x: 0, y: 0, r: 5}
   ```

2. Второй способ — мы можем опустить имена полей, если мы знаем порядок в котором они определены:
   ```go
   c := Circle{0, 0, 5}
   ```

### Поля
Получить доступ к полям можно с помощью оператора `.` (точка):
```go
fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5
```

Давайте изменим функцию `circleArea` так, чтобы она использовала структуру Circle:
```go
func circleArea(c Circle) float64 {
    return math.Pi * c.r * c.r
}
```

В функции `main` у нас будет:
```go
c := Circle{0, 0, 5}
fmt.Println(circleArea(c))
```

Очень важно помнить о том, что аргументы в Go всегда копируются.
Если мы попытаемся изменить любое поле в функции `circleArea`, оригинальная переменная не изменится.
Именно поэтому мы будем писать функции используя указатели:
```go
func circleArea(c *Circle) float64 {
    return math.Pi * c.r * c.r
}
```

И изменим `main`:
```go
c := Circle{0, 0, 5}
fmt.Println(circleArea(&c))
```

### Методы
Несмотря на то, что программа стала лучше, мы все еще можем значительно её улучшить, используя метод — функцию особого типа:
```go
func (c *Circle) area() float64 {
    return math.Pi * c.r * c.r
}
```

Между ключевым словом `func` и именем функции мы добавили «получателя».
Получатель похож на параметр — у него есть имя и тип, но объявление функции таким способом позволяет нам вызывать функцию с помощью оператора .:
```go
fmt.Println(c.area())
```

Это гораздо проще прочесть, нам не нужно использовать оператор `&` (Go автоматически предоставляет доступ к указателю на Circle для этого метода), и поскольку эта функция может быть использована только для Circle мы можем назвать её просто area.

Давайте сделаем то же самое с прямоугольником:
```go
type Rectangle struct {
    x1, y1, x2, y2 float64
}
func (r *Rectangle) area() float64 {
    l := distance(r.x1, r.y1, r.x1, r.y2)
    w := distance(r.x1, r.y1, r.x2, r.y1)
    return l * w
}
```

В main будет написано:
```go
r := Rectangle{0, 0, 10, 10}
fmt.Println(r.area())
```

### Встраиваемые типы
Обычно, поля структур представляют отношения принадлежности (включения).
Например, у Circle (круга) есть radius (радиус).
Предположим, у нас есть структура Person (личность):
```go
type Person struct {
    Name string
}
func (p *Person) Talk() {
    fmt.Println("Hi, my name is", p.Name)
}
```

И если мы хотим создать новую структуру Android, то можем сделать так:
```go
type Android struct {
    Person Person
    Model string
}
```

Это будет работать, но мы можем захотеть создать другое отношение.
Сейчас у андроида «есть» личность, можем ли мы описать отношение андроид «является» личностью?
Go поддерживает подобные отношения с помощью встраиваемых типов, также называемых анонимными полями. Выглядят они так:
```go
type Android struct {
    Person
    Model string
}
```

Мы использовали тип (Person) и не написали его имя.
Объявленная таким способом структура доступна через имя типа:
```go
a := new(Android)
a.Person.Talk()
```

Но мы также можем вызвать любой метод Person прямо из Android:
```go
a := new(Android)
a.Talk()
```

Это отношение работает достаточно интуитивно: личности могут говорить, андроид это личность, значит андроид может говорить.

Также мы можем при создании инициализировать нужные переменные:
```go
var a = Android{
	Model: "model",
	Person: Person {
		Name: "name",
	},
}
```

### Задание
<details><summary>Раскрыть</summary>

В рамках этого урока мы постарались представить себе уже привычные нам переменные и функции, как объекты из реальной жизни.
Чтобы закрепить результат мы предлагаем вам небольшую творческую задачу.

Вам необходимо реализовать структуру со свойствами-полями On, Ammo и Power, с типами bool, int, int соответственно.
У этой структуры должны быть методы: Shoot и RideBike, которые не принимают аргументов, но возвращают значение bool.

Если значение On == false, то оба метода вернут false.

Делать Shoot можно только при наличии Ammo (тогда Ammo уменьшается на единицу, а метод возвращает true), если его нет, то метод вернет false.
Метод RideBike работает также, но только зависит от свойства Power.

Чтобы проверить, что вы все сделали правильно, вы должны создать указатель на экземпляр этой структуры с именем testStruct в функции main, в дальнейшем программа проверит результат.

Закрывающая фигурная скобка в конце main() вам не видна, но она есть.

Пакет main объявлять не нужно!

**Ответ:**
```go
type Rider struct {
	On bool
	Ammo int
	Power int
}

func (r *Rider) Shoot () bool {
	if r.On == false {
		return false
	}

	if r.Ammo > 0 {
		r.Ammo--
		return true
	} else {
		return false
	}
}

func (r *Rider) RideBike () bool {
	if r.On == false {
		return false
	}

	if r.Power > 0 {
		r.Power--
		return true
	} else {
		return false
	}
}

func main() {

	testStruct := &Rider{true, 5, 3}
	/*
	 * Экземпляр созданной вами структуры необходимо передать в качестве
	 * аргумента функции testStruct, которая выполнит проверку соблюдения
	 * всех условий задания/
	 */

// }
```

</details>

## Строки (string)
**Строковые литералы** могут быть созданы с помощью двойных кавычек "Hello World" или с помощью обратных апострофов \`Hello World\`.
Различие между ними в том, что строки в двойных кавычках позволяют использовать особые управляющие последовательности символов.
Например, \n (перенос строки) или \t (символом табуляции).

Строка представляет собой неизменяемую последовательность байтов.
Из этого следует ряд выводов:
* к строке применимы операции, применимые к массивам и срезам;
* чтобы изменить строку, необходимо создать новую строку;
* мы можем итерироваться по строке как и по всякой последовательности, но итерируясь по строке, мы будем итерироваться по байтам, составляющим строку, а не по символам;
* мы можем определить в строке подстроку.

```go
func ExampleString() {
	// Создадим строковый литерал s, значение которого "Это строка".
	// Строка состоит из 10 символов.
	var s string = "Это строка"

	// Однако длина строки len(s) составит 19 байт, т.к. использованные кирилические символы
	// занимают 2 байта, а пробел занимает 1 байт.
	fmt.Printf("Длина строки: %d байт\n", len(s))

	// Посмотрим как взять подстроку
	fmt.Printf("Напечатаем только второе слово в кавычках: \"%v\"\n", s[7:])

	/*
		Попробуем изменить что-то встроке:
		s[3] = 12
		Ошибка компиляции: cannot assign to s[3], потому что строки - неизменяемые последовательности.
	*/

	// "Изменим строку", создав новую
	s = s + " Новая строка"
	fmt.Printf("%v\n", s)

	// А теперь проитерируемся по этой строке
	for _, b := range s {
		fmt.Printf("%v ", b)
	}
	fmt.Print("\n")

	// Output:
	// Длина строки: 19 байт
	// Напечатаем только второе слово в кавычках: "строка"
	// Это строка Новая строка
	// 1069 1090 1086 32 1089 1090 1088 1086 1082 1072 32 1053 1086 1074 1072 1103 32 1089 1090 1088 1086 1082 1072

}
```

В заключение скажем, что строки поддерживают проверку на равенство и неравенство, а вот проверки <> со строками уже не дадут нужного нам результата, т.к. сравнивать Go будет байты, а не символы, т.е. результат для нас может быть не тот, что мы ожидаем (сравнивается не длина строк):
```go
func ExampleEqualString() {
	fmt.Printf("Сравнение на равенство строк \"строка1\" и \"строка2\": %v\n", "строка1" == "строка2")
	fmt.Printf("Сравнение на неравенство строк \"строка1\" и \"строка2\": %v\n", "строка1" != "строка2")

	fmt.Printf("\"Строка1\" > \"Строка2\": %v", "Строка1" > "Строка2")

	// Output:
	// Сравнение на равенство строк "строка1" и "строка2": false
	// Сравнение на неравенство строк "строка1" и "строка2": true
	// "Строка1" > "Строка2": false
}
```

### Функции для работы со строками
Go содержит большое количество функций для работы со строками в пакете `strings` , кратко рассмотрим основные: 
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    fmt.Println(    
        // Содержится ли подстрока в строке    
        strings.Contains("test", "es"), 
        // результат: true

        // Кол-во подстрок в строке
        strings.Count("test", "t"),
        // результат: 2

        // Начинается ли строка с префикса       
        strings.HasPrefix("test", "te"), 
        // результат: true

        // Заканчивается ли строка суффиксом
        strings.HasSuffix("test", "st"), 
        // результат: true

        // Возвращает начальный индекс подстроки в строке, а при отсутствии вхождения возвращает -1
        strings.Index("test", "e"), 
        // результат: 1

        // объединяет массив строк через символ
        strings.Join([]string{"hello","world"}, "-"),
        // результат: "hello-world"

        // Повторяет строку n раз подряд
        strings.Repeat("a", 5), 
        // результат: "aaaaa"

        // Функция Replace заменяет любое вхождение old в вашей строке на new
        // Если значение n равно -1, то будут заменены все вхождения.
        // Общий вид: func Replace(s, old, new string, n int) string
        // Пример:
        strings.Replace("blanotblanot", "not", "***", 	-1),
        // результат: "bla***bla***"
 
        // Разбивает строку согласно разделителю
        strings.Split("a-b-c-d-e", "-"), 
        // результат: []string{"a","b","c","d","e"}

        // Возвращает строку c нижним регистром
        strings.ToLower("TEST"), 
        // результат: "test"

        // Возвращает строку c верхним регистром
        strings.ToUpper("test"), 
        // результат: "TEST"

        // Возвращает строку с вырезанным набором
        strings.Trim("tetstet", "te"),
        // результат: s
    )
}
```

Так как мы рассмотрели только основные функции мы рекомендуем ознакомиться с официальной документацией пакета "strings" - [https://godoc.org/strings](https://godoc.org/strings)

### Байтовые срезы ([]byte)
Когда мы рассматривали строки, то говорили, что строки - это последовательность байт. 
ришло время кратко рассмотреть этот тип данных.
Кратко потому, что байтовый срез (последовательность байт) - это изменяемая последовательность чисел (тип `byte` соответствует типу `uint8`.), из чего мы делаем следующие выводы:
* байтовый срез можно изменять (в отличие от строки);
* к байтовому срезу применимо все, что применимо к массивам и срезам других типов (взятие среза, итерация);
* к отдельным байтам применимы операции, применимые к числам.

```go
func ExampleByteSlice() {
	// Используем тип string, который конвертируем в []byte,
	// чтобы не использовать абстрактные цифры
	bs := []byte("Это байтовый срез")

	fmt.Printf("Так байтовый срез выглядит внутри: %v\n", bs)

	// Продемонстрируем, что байтовый срез можно изменить,
	// а затем напечатаем его в виде строки
	for i := range bs {
		if bs[i]%2 == 0 {
			bs[i] = bs[i] + 1
			continue
		}
		bs[i] = bs[i] - 1
	}

	fmt.Printf("Измененный байтовый срез в виде строки: %s", bs)

	// Output:
	// Так байтовый срез выглядит внутри: [208 173 209 130 208 190 32 208 177 208 176 208 185 209 130 208 190 208 178 209 139 208 185 32 209 129 209 128 208 181 208 183]
	// Измененный байтовый срез в виде строки: ѬЃѿ!ѰѱѸЃѿѳЊѸ!ЀЁѴѶ
}
```

Заканчивая разговор о байтовом срезе нужно сказать, что т.к. этот тип может хранить фактически любые данные и является изменяемым, то регулярно используется в стандартной библиотеке для совершенно разных целей.
Строки же используются значительно реже.

### Срезы рун ([]rune)
Попробуем опять же кратко поговорить о том, что из себя представляет тип `rune`.

Думаю, что все слышали о кодировке Unicode, таблица, в которой собраны все символы из всех мировых систем письменности плюс разнообразные символы ударений и прочие диакритические знаки, управляющие коды наподобие символов табуляции и возврата каретки и многое другое.
Каждому такому символу назначен стандартный номер — код символа Unicode (Unicode code point), или, в терминологии Go, руна (`rune`).

Когда мы говорили о типах `string` и `[]byte`, то выяснили, что 1 символ может занимать более одного байта.
Слегка упрощая мы можем сказать, что тип `[]rune` - это последовательность на самом деле кодов символов, причем 1 символ состоит из 1 кода (тип `rune` соответствует типу `int32`).

Методы работы с типом `[]rune` показаны в следующем примере (обратите внимание на тип используемых в примере кавычек, это не те же самые кавычки, что мы используем при работе со строками):
```go
func ExampleRune() {
	// Поступим также, как в работе с типом []byte
	rs := []rune("Это срез рун")

	// Итерируясь мы будем заменять символ 'р' на '*'
	for i := range rs {
		if rs[i] == 'р' {
			rs[i] = '*'
		}
	}
	fmt.Printf("Измененнный срез в виде строки: %s\n", string(rs))

	// Output:
	// Измененнный срез в виде строки: Это с*ез *ун
}
```

### Unicode

Помимо пакета `strings`, есть некоторые полезные функции из пакета `unicode` для работы с символами.
```go
package main

import (
	"fmt"
	"unicode"
)

func main() {
    // функции ниже принимают на вход тип rune


    // проверка символа на цифру
	fmt.Println(unicode.IsDigit('1')) // true
    // проверка символа на букву
	fmt.Println(unicode.IsLetter('a')) // true 
    // проверка символа на нижний регистр
	fmt.Println(unicode.IsLower('A')) // false
    // проверка символа на верхний регистр
	fmt.Println(unicode.IsUpper('A')) // true
    // проверка символа на пробел 
    // пробел это не только ' ', но и:
    //  '\t', '\n', '\v', '\f', '\r' - подробнее читайте в документации
	fmt.Println(unicode.IsSpace('\t')) // true 

    // С помощью функции Is можно проверять на кастомный RangeTable:
    // например, проверка на латиницу:
 	fmt.Println(unicode.Is(unicode.Latin, 'ы')) // false


    // функции преобразований
	fmt.Println(string(unicode.ToLower('F'))) // f
	fmt.Println(string(unicode.ToUpper('f'))) // F
}
```

Если хотите ознакомиться подробнее с этим пакетом - советуем почитать [документацию](https://golang.org/pkg/unicode/).

### Количество символов в строке
 
Многие новички забывают что функция `len()` возвращает количество байт которое занимает строка, а не количество символов.
Поэтому это будет работать только при использование латиницы и некоторых специальных символов (ASCII), так как они занимают 1 байт на 1 символ.
А вот русские буквы уже занимают 2 байта на символ, мы можем это видеть в примере:

Для получения количества **символов** используйте `utf8.RuneCountInString()`
```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	var en = "english"
	var ru = "русский"
	fmt.Println(len(en), len(ru))
	fmt.Println(utf8.RuneCountInString(en), utf8.RuneCountInString(ru))
}
```

Вывод будет такой:
```
7 14 // en -7 байтов, ru - 14 байтов
7 7 // а длина у строк одинаковая
```

### Задачи
<details><summary>Раскрыть</summary>

#### Задача №1
На вход подается строка. Нужно определить, является ли она правильной или нет. Правильная строка начинается с заглавной буквы и заканчивается точкой. Если строка правильная - вывести Right иначе - вывести Wrong

Маленькая подсказка: fmt.Scan() считывает строку до первого пробела, вы можете считать полностью строку за раз с помощью bufio:

text, _ := bufio.NewReader(os.Stdin).ReadString('\n')

Ответ:
```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"unicode"
)

func main() {
	iText, _ := bufio.NewReader(os.Stdin).ReadString('\n')
	iText = strings.TrimSuffix(iText, "\n")
	iText2 := []rune(iText)

	if unicode.IsUpper(iText2[0]) && iText2[len(iText2)-1] == '.' {
		fmt.Println("Right")
	} else {
		fmt.Println("Wrong")
	}
}
```

#### Задача №2
На вход подается строка.
Нужно определить, является ли она палиндромом.
Если строка является палиндромом - вывести `Палиндром` иначе - вывести `Нет`.
Все входные строчки в нижнем регистре.

Палиндром — буквосочетание, слово или текст, одинаково читающееся в обоих направлениях (например, "топот", "око", "заказ").

Ответ:
```go
package main

import (
	"fmt"
)

func main() {
	var iStrText string
	var isPalindrome bool = true
	fmt.Scan(&iStrText)
	iText := []rune(iStrText)
	leniText := len(iText)

	for i := 0; (i <= leniText / 2) && isPalindrome; i++ {
		if iText[i] != iText[leniText-i-1] {
			isPalindrome = false
		}
	}

	if isPalindrome {
		fmt.Println("Палиндром")
	} else {
		fmt.Println("Нет")
	}
}
```

#### Задание №3
Даются две строки X и S.
Нужно найти и вывести первое вхождение подстроки S в строке X.
Если подстроки S нет в строке X - вывести -1

Ответ:
```go
package main

import (
	"fmt"
)

func main() {
	var iStrText1, iStrText2 string
	var founded bool
	var oN int = -1
	fmt.Scan(&iStrText1, &iStrText2)
	iText1, iText2 := []rune(iStrText1), []rune(iStrText2)

	for i := 0; (i < len(iText1)) && (i + len(iText2) <= len(iText1)) && (!founded); i++ {
		if iText1[i] == iText2[0] {
			if len(iText2) == 1 {
				founded = true
				oN = i
			} else {
				founded = true
				oN = i
				for k := 1; k < len(iText2); k++ {
					if iText1[i+k] != iText2[k] {
						founded = false
						oN = -1
					}
				}
			}
		}
	}

	fmt.Println(oN)
}
```


</details>