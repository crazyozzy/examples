[_TOC_]


# Базовые типы в Go
![img](./assets/data_types.png)

## Целые числа
Для представления целочисленных переменных в Go есть ряд типов, различающихся лишь размерностью и отсутствием или наличием знака в них:
- знаковые: int, int8, int16, int32, int64;
- беззнаковые: uint, uint8, uint16, uint32, uint64.

Если размерности int64 недостаточно, можно воспользоваться типом big.Int из пакета math/big.

## Числа с плавающей точкой
Числа с плавающей точкой представлены в двух вариантах: комплексные и вещественные. Как и у целочисленных типов, у них есть разные размерности:
- комплексные: complex64, complex128;
- вещественные: float32, float64.

Двукратную разницу в размерности легко объяснить: переменные типа complex состоят из двух компонентов типа float.

### Арифметические операции
Для числовых типов доступны следующие арифметические операции:
```
+ — сложение,
- — вычитание,
* — умножение,
/ — деление нацело,
% — остаток от деления.
```

Как и в языке С, для этих операций предусмотрена конструкция сокращения a = a + b до a += b:
```go
var a int 
a = 5
a *= 2 // 'a = a * 2'; 10
```

Также доступны операции инкремента и декремента — сокращения a = a + 1 и a = a - 1 соответственно. В отличие, например, от С++, в Go реализованы только постфиксные версии этих операций.
Пример:
```go
var a int
a = 5
a++ // 'a = a + 1'; 6
a-- // 'a = a - 1'; 5 
```

## Булевы значения
Для работы с логическими выражениями в Go представлен базовый тип bool, который принимает значения true и false:
```go
var a bool
a = true
a = false 
```

## Строки
В Go существует встроенный тип string для представления текстовых данных:
```go
var a string
a = "Hello, world!"
```

Строки в Go представляют собой массив из значений типа byte. По этой причине к элементам строки можно обращаться по индексу, а к самим строкам применима встроенная функция len, которая возвращает её длину в байтах:
```go
var a string
a = "abc"
println(len(a)) // 3
``` 

Строка хранится как массив байт, но он неизменяемый:
```go
var a string
a = "abc"
println(a[2]) // выведет значение второго байта 99
// строки в Go неизменяемы, нельзя написать a[2] = 10
a[2] = 10 // здесь будет ошибка
``` 

В данном случае длина строки в байтах равна количеству элементов, но это не всегда так. Дело в том, что Go из коробки поддерживает Unicode, а значит, строки могут содержать символы, не входящие в таблицу ASCII и не умещающиеся в один байт:
```go
var a string
a = "абц"
println(len(a)) // 6 
```

По этой же причине обращение по индексу иногда может возвращать неожидаемое значение:
```go
var a string
a = "абц"
println(a[5]) // 134
```

Для работы с Unicode в Go предусмотрен встроенный тип rune, способный вместить больше одного байта — любой символ таблицы Unicode. Например, с помощью него можно получить корректное количество символов из предыдущего примера:
```go
import "unicode/utf8"
//...
var a string
a = "абц"
println(utf8.RuneCountInString(a)) // 3
```

Строковые значения в Go можно представить ещё одним способом. Если заключить строковое значение в обратные апострофы ``, а не двойные кавычки "", форматирование строки будет автоматически преобразовано в управляющие символы:
```go
var stringFormattedVar string
// следующие выражения равнозначны 
stringFormattedVar = "Hello,\nworld!\n\n\t\t\"quote!\""
stringFormattedVar = `Hello,
world!

        "quote!"`
``` 

## Пользовательские типы
Как и большинство типизированных языков, Go позволяет программисту декларировать собственные типы. Так, под капотом тип rune определяется как uint32, а byte как uint8:
```go
type rune uint32
type byte uint8
``` 

С помощью определений вы можете создавать новые типы, улучшая читаемость кода. Из-за строгости типизации вы ограничиваете определениями в том числе применимость функций и конструкций к вашим типам:
```go
type Name string
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = fruit // ошибка типизации
             // cannot use fruit (variable of type Fruit) as type Name in assignment
```

Чтобы исправить ошибку в этом листинге, нужно явно привести fruit к Name.
Для пользовательских типов можно определять методы (как для классов в ООП, об этом будет позже в курсе).
```go
// декларация пользовательского типа
type MyType string
// декларация метода для пользовательского типа
func (mt MyType) MethodForMyType() {
    //логика метода
} 
```
Определять методы для встроенных типов в Go нельзя.

## Приведение типов

Чтобы привести один тип к другому, в Go используется такой синтаксис: type(variable). Проиллюстрируем на предыдущем примере:
```go
type Name string
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = Name(fruit) // так, после приведения типов, работает 
```

## Псевдонимы
В Go также есть псевдонимы (aliases) — не путайте с определениями. Псевдонимы позволяют обращаться к типу в коде по другому имени. По синтаксису они похожи на определения:
```go
type MyString = string // MyString здесь — это псевдоним типа string

var a string // можно использовать одно из этих условий для проверки пустой строки
var b MyString
a = b // ошибки нет
```

Можно смешивать псевдонимы и изначальные типы в одном выражении.
Псевдонимы были введены в язык по настоянию Google — для решения задач крупной компании, владельца больших, смежных, пересекающихся code base массивов кода. Применение псевдонимов облегчает масштабный рефакторинг большого объёма уже написанного кода из разных источников. При написании «свежего» кода с чистого листа лучше обходиться без псевдонимов.

## Значения по умолчанию
В отличие от языка C, идейным наследником которого является Go, любая декларация переменной и любая аллокация памяти сопровождаются инициализацией этой памяти. Если в C заявленная переменная может содержать случайное значение, оставшееся в выделенной ей памяти, то в Go переменная сначала гарантированно получает нулевое значение для своего типа.
Все типы имеют значения по умолчанию, которыми автоматически инициируется объявленная переменная, если это не было сделано явно:
- для bool значение по умолчанию — false;
- для числовых типов — 0;
- для ссылочных типов — nil или пустой указатель;
- для string — пустая строка длиной 0.
```go
var str string
// можно использовать одно из этих условий для проверки пустой строки
if str == "" || len(str) == 0 {
...
} 
```


# Переменные и константы

В Go объявление переменной имеет вид: var name type = expression. Можно не указывать тип или оператор присваивания с выражением, но один из них должен присутствовать. Кроме того, существует краткая форма объявления переменной. Рассмотрим все эти варианты:
- Объявление без явного указания типа: var name = expression.
- Длинное объявление с указанием типа: var name type и var name type = expression.
- Короткая нотация: name := expression.
Правил, которые регламентировали бы использование той или иной формы, в Go нет. Можно исходить из личных предпочтений или придерживаться стиля, принятого в вашей компании.

## Объявление без указания типа
Тип переменной можно опускать, если при объявлении происходит инициализация. Тогда тип переменной будет равен типу выражения. Если переменной присваивается число, то компилятор установит тип int или float64.
Опишем в таблице инициализирующие значения и типы, которые компилятор присваивает объявленным переменным:

| Объявление переменной | Тип переменной |
|---|---|
| var i = 10 | int
| var f = 5.0 | float64
| var s = "Hello, world!" | string
| var r = 'Щ' | rune
| var b = true | bool

Множество переменных можно инициализировать через запятую или с помощью вызова функции, которая возвращает несколько значений.
```go
var now = time.Now()  // now равно текущему времени и имеет тип time.Time
var pi, e = 3.1415, 2.7183
var f, err = os.Open("myfile.txt") // os.Open возвращает два значения
```

## Длинное объявление
Если при определении переменной указан только тип, ей будет присвоено нулевое значение этого типа. Если нужно создать несколько переменных одного типа, их можно перечислить через запятую.
```go
var i int // i будет присвоено значение по умолчанию — 0
var s string // s будет равна пустой строке

// определяем три строковых переменных
var name, company, country string 
```

Полная запись с указанием типа и начального значения, как правило, используется тогда, когда тип переменной должен отличаться от типа, который присваивается компилятором по умолчанию.
```go
var id uint32 = 77 
var pi float32 = 3.1415
```

Можно не указывать var перед каждой переменной, а объединять переменные в блоки var (...). Это удобно, когда нужно обозначить схожие по смыслу сущности.
```go
var height int
var length int
var weight float64
var name   string
var company = "Рога и копыта"

// эквивалентно

var (
    height, length int
    weight float64
    name   string
    company = "Рога и копыта"
) 
```

## Короткая нотация
Конструкция с ключевым словом var используется не всегда. В Go есть форма объявления переменной в теле функции с инициализацией. Эту форму принято называть короткой нотацией. Ключевое слово var и тип не указываются, а вместо символа = пишется :=.
```go
i := 10
f := 5.1
doublef := 2*f // doublef имеет тип float64 и равно 10.2

// эквивалентно

var i = 10 
var f = 5.1
var doublef = 2*f  
```

По умолчанию тип переменной равен типу присваиваемого выражения. В случае числовых типов компилятор сам выбирает размерность типа. Это может быть неудобно, когда нужно, например, объявить короткой нотацией переменную типа int64, а не int. Аналогично и с uint.
Проблему решает операция приведения типов:
```go
int64Var := int64(5)
float32Var := float32(101.3)

// эквивалентно

var int64Var int64 = 5 
var floatVar float32 = 101.3
```

Короткая нотация прекрасно работает со множественным объявлением. Но в этом случае хотя бы одна переменная в выражении должна быть новой. В противном случае возникнет ошибка компиляции:
```go
pi, e := 3.1415, 2.7183
// при уточнении значений нельзя использовать :=, так как 
// обе переменных уже определены
pi, e = 3.14159, 2.71828

f, err := os.Open("myfile.txt") 
```

## Константы
Константа — это типизированное значение, которое вычисляется на этапе компиляции и известно компилятору. В отличие от переменной, значение константы не может быть изменено во время работы программы. Вы уже сталкивались с константами ранее — это строковые, булевы и числовые литералы.
```go
var i int = 5 // здесь 5 — безымянная целочисленная константа
s := "Hello " // здесь "Hello" — строковая константа, значением которой
              // инициализирована переменная s
```

Если в коде постоянно используется какое-то число или строка, можно присвоить это значение переменной, но тогда оно не будет защищено от случайного изменения. Для решения этой проблемы Go даёт возможность давать константам имена.
![img](./assets/constants.png)

Именованные константы
Ключевое слово const определяет именованную константу, при этом константе можно присвоить результат некоторого выражения. В одном объявлении const можно определить несколько констант.
Именованные константы можно инициализировать выражениями, состоящими из констант или литералов следующих типов:
- числа;
- строки;
- символы (руны);
- булевы значения.

```go
const pi = 3.14159
const doublePi = pi * 2
const version = "1.0.0"

// эквивалентно

const (
   pi = 3.14159
   doublePi = pi * 2
   version = "1.0.0"
)

func main() {
    fmt.Println(version, pi, doublePi)
}
```

Результат:
```
1.0.0 3.14159 6.28318
```

Именованные константы позволяют изменять значение только в одном месте кода. Например, в приведённом примере легко увеличить точность числа пи или изменить номер версии.
## Нетипизированные константы
Именованные константы могут быть разного типа. Тип связан с хранимым значением:
```go
const intConst = 5 
const floatConst = 5.0
const runeConst = 'A'
const strConst = "Hello, world!"
const boolConst = true
```

Может показаться, что если опустить тип при объявлении константы, то компилятор выберет его сам — как в случае с короткой формой объявления переменных. Это так лишь отчасти. В случае с константами отсутствие явного указания типа имеет большее значение.
Например, если вы объявляете константу intConst и присваиваете ей значение 5, то получаете целочисленную константу с неопределённым типом (untyped int). Конкретный тип значения этой константы ещё не определён и в разных контекстах будет интерпретироваться компилятором по-разному. Это позволяет ослабить типизацию для констант, не отказываясь от сильной типизации глобально.
Благодаря этому подходу будет работать следующий пример:
```go
package main

import (
    "fmt"
)

const id = 100

func main() {
    var i int64 = id
    var f float64 = id

    fmt.Println("i=", i, "f=", f)
}
```

Программа выведет:
```go
i = 100 f = 100
```
Если определить id как переменную var id = 100, то возникнут ошибки компиляции при определении переменных i и f:
```
./prog.go:10:16: cannot use id (variable of type int) as type int64 in variable declaration
./prog.go:11:18: cannot use id (variable of type int) as type float64 in variable declaration
```

Если бы константы, как и переменные в Go, всегда имели конкретный тип, то работать с ними было бы сложнее. Более того, Go позволяет смешивать числовые литералы разных типов (untyped int, untyped float), поэтому корректно следующее выражение:
```go
var a float64
a = 5 + 5.0
```

Константы, как и переменные, можно группировать.
```go
const Program = "Моя программа"
const Version = "1.0.0"

// эквивалентно

const (
   Program = "Моя программа"
   Version = "1.0.0"
)
```

Если в группе у константы не указано значение, то оно равно значению предыдущей константы.
```go
const (
    pi = 3.1415
    e
    name = "John Doe"
    fullName
)

func main() {
    fmt.Println("pi =", pi, "e =", e)
    fmt.Println("name =", name, "fullName =", fullName)
}
```

Результатом работы программы будет:
```go
pi = 3.1415 e = 3.1415
name = John Doe fullName = John Doe
``` 

## Типизированные константы
Если при объявлении вы указываете тип константы явным образом, она становится типизированной и подчиняется правилам сильной типизации Go. В этом случае вы работаете с константой как с неизменяемой переменной:
```go
const flag uint8 = 128

func main() {
    var i int = flag
    fmt.Println(i)
}
```

При компиляции этого примера возникнет ошибка cannot use flag (constant 128 of type uint8) as type int in variable declaration, так как у константы flag тип uint8, а у переменной i тип int.

## Ключевое слово iota
Что, если в коде нужно реализовать перечисление (enum)? В Go для этого нет встроенной синтаксической конструкции или специального типа. Однако можно просто объявить ряд констант и работать с ними:
```go
const (
    Black = "black"
    Gray = "gray"
    White = "white"
)

func main() {
    fmt.Println(Black != Gray) // true
}
```

Зачастую в перечислении важна прежде всего возможность различить два элемента. Значения же этих элементов (в данном случае констант) играют второстепенную роль. Это значит, что необязательно использовать строковые константы — вполне подойдут целочисленные:
```go
const (
    Black = 0
    Gray = 1
    White = 2
)

func main() {
    fmt.Println(Black != Gray) // тоже true
}
```

При таком перечислении вручную есть вероятность получить неожиданное поведение — например, если по ошибке присвоить двум константам в перечислении одинаковое целочисленное значение:
```go
const (
    Black = 0
    Gray = 0
)

func main() {
    fmt.Println(Black != Gray) // false
}
```

К тому же при таком подходе не очень удобно объявлять длинные перечисления.
Для удобного объявления и инициализации блоков констант в Go есть автоматический инкремент iota. При объявлении каждого блока const значение iota равно 0 и увеличивается на 1 для каждого следующего элемента:
```go
const (
    Black = iota
    Gray
    White
)

// счётчик обнуляется
const (
    Yellow = iota
    Red
    Green = iota // это присваивание не обнулит iota
    Blue
)

func main() {
    fmt.Println(Black, Gray, White) 
    fmt.Println(Yellow, Red, Green, Blue)
}
```

Программа выведет:
```go
0 1 2
0 1 2 3
```

Данную конструкцию применяют не только для перечислений. Ключевое слово iota можно также использовать в арифметических выражениях, чтобы быстро объявить ряд значений с прогрессией. Следует помнить, что iota увеличивается на единицу для каждой строки, где указано имя константы, даже если той было присвоено конкретное значение.
```go
const (
    _ = iota*10  // обратите внимание, что можно пропускать константы 
    ten
    hundred
    thousand
)

const (
    hello = "Hello, world!"  // iota равна 0
    one = 1                  // iota равна 1

    black = iota   // iota равна 2
    gray
)

func main() {
    fmt.Println(ten, hundred, thousand)
    fmt.Println(black, gray)
}
```

Программа выведет:
```
10 20 30
2 3
```

## Пользовательские типы в константах
Предположим, нужно определить константы для дней недели.
```go
const (
    Monday = iota + 1
    Tuesday
    //...
    Sunday
)
```

Если перечислить их так, то все константы будут иметь нетипизированный числовой тип и могут использоваться в любых выражениях, что может вносить путаницу: var i int = Monday + 1. В подобных случаях стоит определить пользовательский тип и указать его при определении констант.
```go
type Weekday int

const (
    Monday Weekday = iota + 1
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)

func NextDay(day Weekday) Weekday {
    return (day % 7) + 1
}

func main() {
    var today Weekday = Sunday
    tomorrow := NextDay(today)
    fmt.Println("today =", today, "tomorrow =", tomorrow)
}
```

Программа выведет:
```go
today = 7 tomorrow = 1
```

## Литералы
В Go можно использовать различные представления строковых и числовых литералов. Проиллюстрируем на примере целого числа 1000:
```
1000
1000.0
1_000 // можно разделять части числа символом '_' для удобства восприятия
01750 // восьмеричное представление, начинается с 0
0x3e8 // шестнадцатеричное представление
0b001111101000 // бинарное представление
```

Любой из этих литералов может быть использован в выражениях и даст одно и то же значение.



# Область видимости
**Область видимости (scope)** определяет набор правил, по которым осуществляется доступ к объявленным переменным, константам и функциям из различных блоков кода.
В Go область видимости можно охарактеризовать двумя параметрами:
- глобальность/локальность;
- экспортируемость/неэкспортируемость.

## Глобальность/локальность
Объявленные в теле функций переменные, константы и функции характеризуются как **локальные**, то есть их область видимости ограничена тем блоком кода, в котором они объявлены.
В Go локальные переменные можно объявлять ключевым словом var или короткой нотацией :=.
Рассмотрим пример, который иллюстрирует область видимости локальной переменной:
```go
func main() {
    i := 10
    if i == 10 {
        // изменяем значение переменной i
        i += 5 
        if i == 15 {
            // в этом блоке создаётся новая переменная i, которая
            // перекрывает определённую выше переменную с таким же именем
            // следует избегать таких ситуаций на практике
            i := 7
            fmt.Println(i)
            // область видимости этой переменной ограничена блоком
        }
    }
    fmt.Println(i)
}
```

Выведет:
```
7
15
```

Объявленные вне тела функции сущности характеризуются как глобальные и находятся в области видимости всех блоков кода в пакете. То есть глобальные объекты доступны во всех файлах, находящихся в одной директории.

Глобальные переменные нельзя объявлять короткой нотацией :=, необходимо ключевое слово var. Если глобальная переменная не инициализирована, она принимает нулевое значение указанного типа.
```go
// Глобальные константа и переменные.
const program = "Моё приложение"

var name string
var ver = "v1.0.0" // инициализируем глобальную переменную

func main() {
    // изменяем глобальную переменную name
    name = "Вася"
    fmt.Println("Привет, " + name + "!")
    fmt.Println("Добро пожаловать в", program, ver)
}
```

Выведет:
```
Привет, Вася!
Добро пожаловать в Моё приложение v1.0.0
```
![img](./assets/global_local.png)


## Экспортируемость/неэкспортируемость
Если предыдущее свойство характеризует доступность объекта внутри пакета, то экспортируемость регламентирует доступность из других пакетов.

`Экспортируемыми могут быть только глобальные сущности.`

**Экспортируемые** переменные, константы и функции определённого пакета доступны из тех пакетов, которые импортируют этот пакет ключевым словом `import`.
Доступ к экспортируемым объектам осуществляется конструкцией `<имя пакета>.<Имя сущности>`. Проиллюстрируем на примере `Hello, world!`:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}
```

Здесь в функции `main` программа обращается к пакету стандартной библиотеки `fmt`, вызывая её экспортируемую функцию `Println`.

`Как Go определяет, что сущность экспортируемая? Если имя переменной, константы или функции начинается с прописной буквы, то она экспортируемая. Если со строчной, то неэкспортируемая.`

К **неэкспортируемым** сущностям нельзя обратиться за пределами пакета. Этот подход — часть того особенного ООП, который реализует в Go сокрытие данных или `инкапсуляцию`.
![img](./assets/export.png)

Проиллюстрируем на примере определение экспортируемых и неэкспортируемых объектов.
```go
package contacts

// Email 
const Email = "support@example.com" // глобальная экспортируемая константа

var support string // глобальная неэкспортируемая переменная

// SetSupport устанавливает значение переменной support.
func SetSupport(s string) { 
    support = s
}

// GetContact возвращает имя и email.
func GetContact() string {
    return fmt.Sprintf("%s <%s>", support, Email)
}
```

Если импортировать этот пакет, то будут доступны константа `Email`, функции `SetSupport` и `GetContact`.
```go
package main

import (
    "fmt"
    "internal/contacts"
)

func main() {
    contacts.SetSupport("Служба поддержки")
    fmt.Println(contacts.GetContact())
    fmt.Println("Email:", contacts.Email)
}
```

Выведет:
```
Служба поддержки <support@example.com>
Email: support@example.com
```



# Операторы ветвления
В ситуациях, когда ход работы программы должен меняться в зависимости от условия, применяют операторы ветвления, или, как их ещё называют, условные операторы. В языке Go есть как стандартные условные операторы, так и специфичные для языка.
Для начала вспомним операторы сравнения (переменных одного типа):
```
> — больше;
< — меньше;
>= — больше или равно;
<= — меньше или равно;
== — равно;
!= — не равно.
```

А также логические операторы:
```
&& — логическое И;
|| — логическое ИЛИ;
! — логическое НЕ.
```

## Условие if — else
```
if a == 1 {
    // сценарий, если условие if выполнено
} else if a == 2 {
    // сценарий, если условие else if выполнено
} else {
    // сценарий, если условие else if не выполнено
} 
```
Это простой пример условной конструкции. Она может состоять только из одного оператора if — тогда блок кода сработает, если условие верно, а если неверно, то ничего не произойдёт.

Опционально можно добавить оператор else. За ним будет следовать блок кода, который выполнится, если исходное условие неверно.

И наконец, если нужно обработать несколько различных условий, используют оператор else if. В код можно добавить много else if, но это не самый «читабельный» вариант — в подобных случаях лучше использовать case, о котором расскажем ниже.

Приведём примеры операторов с различными вариантами условий:
```
// логическое НЕ
// возвращается одна переменная типа bool
a := false
if !a {} 

// логическое И
var a, b int
if a == 1 && b == 2 {}

// исключающее ИЛИ (XOR)
var a, b bool
if (a || b) && !(a && b) {} 
```

### Общие правила для условных операторов:
1. Обязательно использовать фигурные скобки { }, чтобы обозначить область видимости оператора.
2. Необязательно заключать основное условие в круглые скобки ( ), но с ними удобнее читать код.
3. Можно добавлять круглые скобки ( ), чтобы группировать части условия.

В Go применяется «ленивая» проверка условий: она идёт слева направо до первого false и прекращается, потому что проверять дальше нет смысла. Пример «ленивой» проверки:
```
a, b := 1, 0

if a == 1 || b == 2 {
    fmt.Println("Hello")
} 
```
В данном примере выполняется левое условие, поэтому проверки (или выполнения) правой части не последует. Пример будет более показателен, если для правой части условия использовать функциональный литерал (подробнее расскажем в теме «Функции»), который будет просто изменять значение переменной b.
```
a, b := 1, 0

incB := func() bool {
    b = b + 1
    return true
}

if a == 1 || incB() {
    fmt.Println("Hello")
}

fmt.Println(a, b) 
```
```
Hello
1 0
```
Из-за «ленивой» проверки условий функция incB не выполнится — её значение не изменится, то есть функция не изменит значение переменной, потому что выполнение кода прервётся.

Оператор if может состоять из двух компонент: инициализации и основного условия. Такая техника позволяет объявлять локальную переменную, которую используют только в рамках области видимости if. Это может пригодиться, например, когда нужно преобразовать данные для сравнения.
```
a := 0.10000001 // float64
// инициализация и основное условие
if b := float32(a); b > float32(0.1) {
    fmt.Println("Var a is GT float32(0.1)")
} 
```
Условие в данном примере может перестать выполняться, если добавить ещё один ноль: 0.100000001. Тип float32 обеспечивает точность в восемь десятичных чисел, в то время как точность float64 составляет около 15 чисел.

## Условие switch — case
```go
var a int

switch a {
case 1:
    fmt.Println("1")
case 2:
    fmt.Println("2")
case 3, 4:
    fmt.Println("3 or 4")
default:
    fmt.Println("Default case")
} 
```
Конструкция switch — case позволяет избежать дублирования else if. Проверка условий идёт сверху вниз и слева направо, поэтому в примере выше условия будут проверяться в таком порядке: 1, 2, 3, 4.

Наличие блока default необязательно — его можно опустить, если не требуется описывать «стандартное» поведение. Этот блок выполнится, если ни одно из условий не отработало.

Основное условие switch может быть не задано явно:
```go
var a int

switch {
case a == 100:
    fmt.Println("EQ 100")
case a > 0:
    fmt.Println("GT 0 AND NEQ 100")
case a < 0:
    fmt.Println("LT 0 AND NEQ 100")
} 
```
В этом примере важен порядок условий case: если переместить a == 100 в конец, то a > 0 всегда будет срабатывать первым для положительных чисел. Такая форма оператора аналогична множественному else if.

Внутри switch можно объявить локальную переменную, доступную только в пределах области видимости оператора:
```go
a := 6
switch b := a % 5; {
case b == 0:
    fmt.Println("Кратно 5")
default:
    fmt.Printf("Остаток от деления на 5: %d", b)
}
```
Чтобы досрочно прервать выполнение case, используют ключевое слово break. Это бывает полезно, когда внутри case есть условные конструкции. В Go нет необходимости явно указывать break в конце каждого case, так как следующий блок case автоматически не выполнится при совпадении условия.

Когда нужно всё-таки выполнить следующий блок, используют ключевое слово fallthrough. Если указать его в конце блока кода, то после него будет выполнен блок в следующем case или default.
```go
a := -100
switch {
case a > 0:
    if a % 2 == 0 {
        break
    }
    fmt.Println("Odd positive value received")
case a < 0:
    fmt.Println("Negative value received")
    fallthrough
default:
    fmt.Println("Default value handling")
} 
```
У ключевого слова fallthrough есть особенности:
- его можно использовать только в последней строке case, иначе будет ошибка компиляции;
- оно игнорирует условие следующего по порядку case.



