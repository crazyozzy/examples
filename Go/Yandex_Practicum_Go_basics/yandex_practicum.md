# Базовые типы в Go
![img](./assets/data_types.png)

## Целые числа
Для представления целочисленных переменных в Go есть ряд типов, различающихся лишь размерностью и отсутствием или наличием знака в них:
- знаковые: int, int8, int16, int32, int64;
- беззнаковые: uint, uint8, uint16, uint32, uint64.

Если размерности int64 недостаточно, можно воспользоваться типом big.Int из пакета math/big.

## Числа с плавающей точкой
Числа с плавающей точкой представлены в двух вариантах: комплексные и вещественные. Как и у целочисленных типов, у них есть разные размерности:
- комплексные: complex64, complex128;
- вещественные: float32, float64.

Двукратную разницу в размерности легко объяснить: переменные типа complex состоят из двух компонентов типа float.

### Арифметические операции
Для числовых типов доступны следующие арифметические операции:
```
+ — сложение,
- — вычитание,
* — умножение,
/ — деление нацело,
% — остаток от деления.
```

Как и в языке С, для этих операций предусмотрена конструкция сокращения a = a + b до a += b:
```go
var a int 
a = 5
a *= 2 // 'a = a * 2'; 10
```

Также доступны операции инкремента и декремента — сокращения a = a + 1 и a = a - 1 соответственно. В отличие, например, от С++, в Go реализованы только постфиксные версии этих операций.
Пример:
```go
var a int
a = 5
a++ // 'a = a + 1'; 6
a-- // 'a = a - 1'; 5 
```

## Булевы значения
Для работы с логическими выражениями в Go представлен базовый тип bool, который принимает значения true и false:
```go
var a bool
a = true
a = false 
```

## Строки
В Go существует встроенный тип string для представления текстовых данных:
```go
var a string
a = "Hello, world!"
```

Строки в Go представляют собой массив из значений типа byte. По этой причине к элементам строки можно обращаться по индексу, а к самим строкам применима встроенная функция len, которая возвращает её длину в байтах:
```go
var a string
a = "abc"
println(len(a)) // 3
``` 

Строка хранится как массив байт, но он неизменяемый:
```go
var a string
a = "abc"
println(a[2]) // выведет значение второго байта 99
// строки в Go неизменяемы, нельзя написать a[2] = 10
a[2] = 10 // здесь будет ошибка
``` 

В данном случае длина строки в байтах равна количеству элементов, но это не всегда так. Дело в том, что Go из коробки поддерживает Unicode, а значит, строки могут содержать символы, не входящие в таблицу ASCII и не умещающиеся в один байт:
```go
var a string
a = "абц"
println(len(a)) // 6 
```

По этой же причине обращение по индексу иногда может возвращать неожидаемое значение:
```go
var a string
a = "абц"
println(a[5]) // 134
```

Для работы с Unicode в Go предусмотрен встроенный тип rune, способный вместить больше одного байта — любой символ таблицы Unicode. Например, с помощью него можно получить корректное количество символов из предыдущего примера:
```go
import "unicode/utf8"
//...
var a string
a = "абц"
println(utf8.RuneCountInString(a)) // 3
```

Строковые значения в Go можно представить ещё одним способом. Если заключить строковое значение в обратные апострофы ``, а не двойные кавычки "", форматирование строки будет автоматически преобразовано в управляющие символы:
```go
var stringFormattedVar string
// следующие выражения равнозначны 
stringFormattedVar = "Hello,\nworld!\n\n\t\t\"quote!\""
stringFormattedVar = `Hello,
world!

        "quote!"`
``` 

## Пользовательские типы
Как и большинство типизированных языков, Go позволяет программисту декларировать собственные типы. Так, под капотом тип rune определяется как uint32, а byte как uint8:
```go
type rune uint32
type byte uint8
``` 

С помощью определений вы можете создавать новые типы, улучшая читаемость кода. Из-за строгости типизации вы ограничиваете определениями в том числе применимость функций и конструкций к вашим типам:
```go
type Name string
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = fruit // ошибка типизации
             // cannot use fruit (variable of type Fruit) as type Name in assignment
```

Чтобы исправить ошибку в этом листинге, нужно явно привести fruit к Name.
Для пользовательских типов можно определять методы (как для классов в ООП, об этом будет позже в курсе).
```go
// декларация пользовательского типа
type MyType string
// декларация метода для пользовательского типа
func (mt MyType) MethodForMyType() {
    //логика метода
} 
```
Определять методы для встроенных типов в Go нельзя.

## Приведение типов

Чтобы привести один тип к другому, в Go используется такой синтаксис: type(variable). Проиллюстрируем на предыдущем примере:
```go
type Name string
type Fruit string

var fruit Fruit
var name Name

fruit = "Apple"
name = Name(fruit) // так, после приведения типов, работает 
```

## Псевдонимы
В Go также есть псевдонимы (aliases) — не путайте с определениями. Псевдонимы позволяют обращаться к типу в коде по другому имени. По синтаксису они похожи на определения:
```go
type MyString = string // MyString здесь — это псевдоним типа string

var a string // можно использовать одно из этих условий для проверки пустой строки
var b MyString
a = b // ошибки нет
```

Можно смешивать псевдонимы и изначальные типы в одном выражении.
Псевдонимы были введены в язык по настоянию Google — для решения задач крупной компании, владельца больших, смежных, пересекающихся code base массивов кода. Применение псевдонимов облегчает масштабный рефакторинг большого объёма уже написанного кода из разных источников. При написании «свежего» кода с чистого листа лучше обходиться без псевдонимов.

## Значения по умолчанию
В отличие от языка C, идейным наследником которого является Go, любая декларация переменной и любая аллокация памяти сопровождаются инициализацией этой памяти. Если в C заявленная переменная может содержать случайное значение, оставшееся в выделенной ей памяти, то в Go переменная сначала гарантированно получает нулевое значение для своего типа.
Все типы имеют значения по умолчанию, которыми автоматически инициируется объявленная переменная, если это не было сделано явно:
- для bool значение по умолчанию — false;
- для числовых типов — 0;
- для ссылочных типов — nil или пустой указатель;
- для string — пустая строка длиной 0.
```go
var str string
// можно использовать одно из этих условий для проверки пустой строки
if str == "" || len(str) == 0 {
...
} 
```


# Переменные и константы

В Go объявление переменной имеет вид: var name type = expression. Можно не указывать тип или оператор присваивания с выражением, но один из них должен присутствовать. Кроме того, существует краткая форма объявления переменной. Рассмотрим все эти варианты:
- Объявление без явного указания типа: var name = expression.
- Длинное объявление с указанием типа: var name type и var name type = expression.
- Короткая нотация: name := expression.
Правил, которые регламентировали бы использование той или иной формы, в Go нет. Можно исходить из личных предпочтений или придерживаться стиля, принятого в вашей компании.

## Объявление без указания типа
Тип переменной можно опускать, если при объявлении происходит инициализация. Тогда тип переменной будет равен типу выражения. Если переменной присваивается число, то компилятор установит тип int или float64.
Опишем в таблице инициализирующие значения и типы, которые компилятор присваивает объявленным переменным:

| Объявление переменной | Тип переменной |
|---|---|
| var i = 10 | int
| var f = 5.0 | float64
| var s = "Hello, world!" | string
| var r = 'Щ' | rune
| var b = true | bool

Множество переменных можно инициализировать через запятую или с помощью вызова функции, которая возвращает несколько значений.
```go
var now = time.Now()  // now равно текущему времени и имеет тип time.Time
var pi, e = 3.1415, 2.7183
var f, err = os.Open("myfile.txt") // os.Open возвращает два значения
```

## Длинное объявление
Если при определении переменной указан только тип, ей будет присвоено нулевое значение этого типа. Если нужно создать несколько переменных одного типа, их можно перечислить через запятую.
```go
var i int // i будет присвоено значение по умолчанию — 0
var s string // s будет равна пустой строке

// определяем три строковых переменных
var name, company, country string 
```

Полная запись с указанием типа и начального значения, как правило, используется тогда, когда тип переменной должен отличаться от типа, который присваивается компилятором по умолчанию.
```go
var id uint32 = 77 
var pi float32 = 3.1415
```

Можно не указывать var перед каждой переменной, а объединять переменные в блоки var (...). Это удобно, когда нужно обозначить схожие по смыслу сущности.
```go
var height int
var length int
var weight float64
var name   string
var company = "Рога и копыта"

// эквивалентно

var (
    height, length int
    weight float64
    name   string
    company = "Рога и копыта"
) 
```

## Короткая нотация
Конструкция с ключевым словом var используется не всегда. В Go есть форма объявления переменной в теле функции с инициализацией. Эту форму принято называть короткой нотацией. Ключевое слово var и тип не указываются, а вместо символа = пишется :=.
```go
i := 10
f := 5.1
doublef := 2*f // doublef имеет тип float64 и равно 10.2

// эквивалентно

var i = 10 
var f = 5.1
var doublef = 2*f  
```

По умолчанию тип переменной равен типу присваиваемого выражения. В случае числовых типов компилятор сам выбирает размерность типа. Это может быть неудобно, когда нужно, например, объявить короткой нотацией переменную типа int64, а не int. Аналогично и с uint.
Проблему решает операция приведения типов:
```go
int64Var := int64(5)
float32Var := float32(101.3)

// эквивалентно

var int64Var int64 = 5 
var floatVar float32 = 101.3
```

Короткая нотация прекрасно работает со множественным объявлением. Но в этом случае хотя бы одна переменная в выражении должна быть новой. В противном случае возникнет ошибка компиляции:
```go
pi, e := 3.1415, 2.7183
// при уточнении значений нельзя использовать :=, так как 
// обе переменных уже определены
pi, e = 3.14159, 2.71828

f, err := os.Open("myfile.txt") 
```

## Константы
Константа — это типизированное значение, которое вычисляется на этапе компиляции и известно компилятору. В отличие от переменной, значение константы не может быть изменено во время работы программы. Вы уже сталкивались с константами ранее — это строковые, булевы и числовые литералы.
```go
var i int = 5 // здесь 5 — безымянная целочисленная константа
s := "Hello " // здесь "Hello" — строковая константа, значением которой
              // инициализирована переменная s
```

Если в коде постоянно используется какое-то число или строка, можно присвоить это значение переменной, но тогда оно не будет защищено от случайного изменения. Для решения этой проблемы Go даёт возможность давать константам имена.
![img](./assets/constants.png)

Именованные константы
Ключевое слово const определяет именованную константу, при этом константе можно присвоить результат некоторого выражения. В одном объявлении const можно определить несколько констант.
Именованные константы можно инициализировать выражениями, состоящими из констант или литералов следующих типов:
- числа;
- строки;
- символы (руны);
- булевы значения.

```go
const pi = 3.14159
const doublePi = pi * 2
const version = "1.0.0"

// эквивалентно

const (
   pi = 3.14159
   doublePi = pi * 2
   version = "1.0.0"
)

func main() {
    fmt.Println(version, pi, doublePi)
}
```

Результат:
```
1.0.0 3.14159 6.28318
```

Именованные константы позволяют изменять значение только в одном месте кода. Например, в приведённом примере легко увеличить точность числа пи или изменить номер версии.
## Нетипизированные константы
Именованные константы могут быть разного типа. Тип связан с хранимым значением:
```go
const intConst = 5 
const floatConst = 5.0
const runeConst = 'A'
const strConst = "Hello, world!"
const boolConst = true
```

Может показаться, что если опустить тип при объявлении константы, то компилятор выберет его сам — как в случае с короткой формой объявления переменных. Это так лишь отчасти. В случае с константами отсутствие явного указания типа имеет большее значение.
Например, если вы объявляете константу intConst и присваиваете ей значение 5, то получаете целочисленную константу с неопределённым типом (untyped int). Конкретный тип значения этой константы ещё не определён и в разных контекстах будет интерпретироваться компилятором по-разному. Это позволяет ослабить типизацию для констант, не отказываясь от сильной типизации глобально.
Благодаря этому подходу будет работать следующий пример:
```go
package main

import (
    "fmt"
)

const id = 100

func main() {
    var i int64 = id
    var f float64 = id

    fmt.Println("i=", i, "f=", f)
}
```

Программа выведет:
```go
i = 100 f = 100
```
Если определить id как переменную var id = 100, то возникнут ошибки компиляции при определении переменных i и f:
```
./prog.go:10:16: cannot use id (variable of type int) as type int64 in variable declaration
./prog.go:11:18: cannot use id (variable of type int) as type float64 in variable declaration
```

Если бы константы, как и переменные в Go, всегда имели конкретный тип, то работать с ними было бы сложнее. Более того, Go позволяет смешивать числовые литералы разных типов (untyped int, untyped float), поэтому корректно следующее выражение:
```go
var a float64
a = 5 + 5.0
```

Константы, как и переменные, можно группировать.
```go
const Program = "Моя программа"
const Version = "1.0.0"

// эквивалентно

const (
   Program = "Моя программа"
   Version = "1.0.0"
)
```

Если в группе у константы не указано значение, то оно равно значению предыдущей константы.
```go
const (
    pi = 3.1415
    e
    name = "John Doe"
    fullName
)

func main() {
    fmt.Println("pi =", pi, "e =", e)
    fmt.Println("name =", name, "fullName =", fullName)
}
```

Результатом работы программы будет:
```go
pi = 3.1415 e = 3.1415
name = John Doe fullName = John Doe
``` 

## Типизированные константы
Если при объявлении вы указываете тип константы явным образом, она становится типизированной и подчиняется правилам сильной типизации Go. В этом случае вы работаете с константой как с неизменяемой переменной:
```go
const flag uint8 = 128

func main() {
    var i int = flag
    fmt.Println(i)
}
```

При компиляции этого примера возникнет ошибка cannot use flag (constant 128 of type uint8) as type int in variable declaration, так как у константы flag тип uint8, а у переменной i тип int.

## Ключевое слово iota
Что, если в коде нужно реализовать перечисление (enum)? В Go для этого нет встроенной синтаксической конструкции или специального типа. Однако можно просто объявить ряд констант и работать с ними:
```go
const (
    Black = "black"
    Gray = "gray"
    White = "white"
)

func main() {
    fmt.Println(Black != Gray) // true
}
```

Зачастую в перечислении важна прежде всего возможность различить два элемента. Значения же этих элементов (в данном случае констант) играют второстепенную роль. Это значит, что необязательно использовать строковые константы — вполне подойдут целочисленные:
```go
const (
    Black = 0
    Gray = 1
    White = 2
)

func main() {
    fmt.Println(Black != Gray) // тоже true
}
```

При таком перечислении вручную есть вероятность получить неожиданное поведение — например, если по ошибке присвоить двум константам в перечислении одинаковое целочисленное значение:
```go
const (
    Black = 0
    Gray = 0
)

func main() {
    fmt.Println(Black != Gray) // false
}
```

К тому же при таком подходе не очень удобно объявлять длинные перечисления.
Для удобного объявления и инициализации блоков констант в Go есть автоматический инкремент iota. При объявлении каждого блока const значение iota равно 0 и увеличивается на 1 для каждого следующего элемента:
```go
const (
    Black = iota
    Gray
    White
)

// счётчик обнуляется
const (
    Yellow = iota
    Red
    Green = iota // это присваивание не обнулит iota
    Blue
)

func main() {
    fmt.Println(Black, Gray, White) 
    fmt.Println(Yellow, Red, Green, Blue)
}
```

Программа выведет:
```go
0 1 2
0 1 2 3
```

Данную конструкцию применяют не только для перечислений. Ключевое слово iota можно также использовать в арифметических выражениях, чтобы быстро объявить ряд значений с прогрессией. Следует помнить, что iota увеличивается на единицу для каждой строки, где указано имя константы, даже если той было присвоено конкретное значение.
```go
const (
    _ = iota*10  // обратите внимание, что можно пропускать константы 
    ten
    hundred
    thousand
)

const (
    hello = "Hello, world!"  // iota равна 0
    one = 1                  // iota равна 1

    black = iota   // iota равна 2
    gray
)

func main() {
    fmt.Println(ten, hundred, thousand)
    fmt.Println(black, gray)
}
```

Программа выведет:
```
10 20 30
2 3
```

## Пользовательские типы в константах
Предположим, нужно определить константы для дней недели.
```go
const (
    Monday = iota + 1
    Tuesday
    //...
    Sunday
)
```

Если перечислить их так, то все константы будут иметь нетипизированный числовой тип и могут использоваться в любых выражениях, что может вносить путаницу: var i int = Monday + 1. В подобных случаях стоит определить пользовательский тип и указать его при определении констант.
```go
type Weekday int

const (
    Monday Weekday = iota + 1
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)

func NextDay(day Weekday) Weekday {
    return (day % 7) + 1
}

func main() {
    var today Weekday = Sunday
    tomorrow := NextDay(today)
    fmt.Println("today =", today, "tomorrow =", tomorrow)
}
```

Программа выведет:
```go
today = 7 tomorrow = 1
```

## Литералы
В Go можно использовать различные представления строковых и числовых литералов. Проиллюстрируем на примере целого числа 1000:
```
1000
1000.0
1_000 // можно разделять части числа символом '_' для удобства восприятия
01750 // восьмеричное представление, начинается с 0
0x3e8 // шестнадцатеричное представление
0b001111101000 // бинарное представление
```

Любой из этих литералов может быть использован в выражениях и даст одно и то же значение.



# Область видимости
**Область видимости (scope)** определяет набор правил, по которым осуществляется доступ к объявленным переменным, константам и функциям из различных блоков кода.
В Go область видимости можно охарактеризовать двумя параметрами:
- глобальность/локальность;
- экспортируемость/неэкспортируемость.

## Глобальность/локальность
Объявленные в теле функций переменные, константы и функции характеризуются как **локальные**, то есть их область видимости ограничена тем блоком кода, в котором они объявлены.
В Go локальные переменные можно объявлять ключевым словом var или короткой нотацией :=.
Рассмотрим пример, который иллюстрирует область видимости локальной переменной:
```go
func main() {
    i := 10
    if i == 10 {
        // изменяем значение переменной i
        i += 5 
        if i == 15 {
            // в этом блоке создаётся новая переменная i, которая
            // перекрывает определённую выше переменную с таким же именем
            // следует избегать таких ситуаций на практике
            i := 7
            fmt.Println(i)
            // область видимости этой переменной ограничена блоком
        }
    }
    fmt.Println(i)
}
```

Выведет:
```
7
15
```

Объявленные вне тела функции сущности характеризуются как глобальные и находятся в области видимости всех блоков кода в пакете. То есть глобальные объекты доступны во всех файлах, находящихся в одной директории.

Глобальные переменные нельзя объявлять короткой нотацией :=, необходимо ключевое слово var. Если глобальная переменная не инициализирована, она принимает нулевое значение указанного типа.
```go
// Глобальные константа и переменные.
const program = "Моё приложение"

var name string
var ver = "v1.0.0" // инициализируем глобальную переменную

func main() {
    // изменяем глобальную переменную name
    name = "Вася"
    fmt.Println("Привет, " + name + "!")
    fmt.Println("Добро пожаловать в", program, ver)
}
```

Выведет:
```
Привет, Вася!
Добро пожаловать в Моё приложение v1.0.0
```
![img](./assets/global_local.png)


## Экспортируемость/неэкспортируемость
Если предыдущее свойство характеризует доступность объекта внутри пакета, то экспортируемость регламентирует доступность из других пакетов.

`Экспортируемыми могут быть только глобальные сущности.`

**Экспортируемые** переменные, константы и функции определённого пакета доступны из тех пакетов, которые импортируют этот пакет ключевым словом `import`.
Доступ к экспортируемым объектам осуществляется конструкцией `<имя пакета>.<Имя сущности>`. Проиллюстрируем на примере `Hello, world!`:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, world!")
}
```

Здесь в функции `main` программа обращается к пакету стандартной библиотеки `fmt`, вызывая её экспортируемую функцию `Println`.

`Как Go определяет, что сущность экспортируемая? Если имя переменной, константы или функции начинается с прописной буквы, то она экспортируемая. Если со строчной, то неэкспортируемая.`

К **неэкспортируемым** сущностям нельзя обратиться за пределами пакета. Этот подход — часть того особенного ООП, который реализует в Go сокрытие данных или `инкапсуляцию`.
![img](./assets/export.png)

Проиллюстрируем на примере определение экспортируемых и неэкспортируемых объектов.
```go
package contacts

// Email 
const Email = "support@example.com" // глобальная экспортируемая константа

var support string // глобальная неэкспортируемая переменная

// SetSupport устанавливает значение переменной support.
func SetSupport(s string) { 
    support = s
}

// GetContact возвращает имя и email.
func GetContact() string {
    return fmt.Sprintf("%s <%s>", support, Email)
}
```

Если импортировать этот пакет, то будут доступны константа `Email`, функции `SetSupport` и `GetContact`.
```go
package main

import (
    "fmt"
    "internal/contacts"
)

func main() {
    contacts.SetSupport("Служба поддержки")
    fmt.Println(contacts.GetContact())
    fmt.Println("Email:", contacts.Email)
}
```

Выведет:
```
Служба поддержки <support@example.com>
Email: support@example.com
```



# Операторы ветвления
В ситуациях, когда ход работы программы должен меняться в зависимости от условия, применяют операторы ветвления, или, как их ещё называют, условные операторы. В языке Go есть как стандартные условные операторы, так и специфичные для языка.
Для начала вспомним операторы сравнения (переменных одного типа):
```
> — больше;
< — меньше;
>= — больше или равно;
<= — меньше или равно;
== — равно;
!= — не равно.
```

А также логические операторы:
```
&& — логическое И;
|| — логическое ИЛИ;
! — логическое НЕ.
```

## Условие if — else
```
if a == 1 {
    // сценарий, если условие if выполнено
} else if a == 2 {
    // сценарий, если условие else if выполнено
} else {
    // сценарий, если условие else if не выполнено
} 
```
Это простой пример условной конструкции. Она может состоять только из одного оператора if — тогда блок кода сработает, если условие верно, а если неверно, то ничего не произойдёт.

Опционально можно добавить оператор else. За ним будет следовать блок кода, который выполнится, если исходное условие неверно.

И наконец, если нужно обработать несколько различных условий, используют оператор else if. В код можно добавить много else if, но это не самый «читабельный» вариант — в подобных случаях лучше использовать case, о котором расскажем ниже.

Приведём примеры операторов с различными вариантами условий:
```
// логическое НЕ
// возвращается одна переменная типа bool
a := false
if !a {} 

// логическое И
var a, b int
if a == 1 && b == 2 {}

// исключающее ИЛИ (XOR)
var a, b bool
if (a || b) && !(a && b) {} 
```

### Общие правила для условных операторов:
1. Обязательно использовать фигурные скобки { }, чтобы обозначить область видимости оператора.
2. Необязательно заключать основное условие в круглые скобки ( ), но с ними удобнее читать код.
3. Можно добавлять круглые скобки ( ), чтобы группировать части условия.

В Go применяется «ленивая» проверка условий: она идёт слева направо до первого false и прекращается, потому что проверять дальше нет смысла. Пример «ленивой» проверки:
```
a, b := 1, 0

if a == 1 || b == 2 {
    fmt.Println("Hello")
} 
```
В данном примере выполняется левое условие, поэтому проверки (или выполнения) правой части не последует. Пример будет более показателен, если для правой части условия использовать функциональный литерал (подробнее расскажем в теме «Функции»), который будет просто изменять значение переменной b.
```
a, b := 1, 0

incB := func() bool {
    b = b + 1
    return true
}

if a == 1 || incB() {
    fmt.Println("Hello")
}

fmt.Println(a, b) 
```
```
Hello
1 0
```
Из-за «ленивой» проверки условий функция incB не выполнится — её значение не изменится, то есть функция не изменит значение переменной, потому что выполнение кода прервётся.

Оператор if может состоять из двух компонент: инициализации и основного условия. Такая техника позволяет объявлять локальную переменную, которую используют только в рамках области видимости if. Это может пригодиться, например, когда нужно преобразовать данные для сравнения.
```
a := 0.10000001 // float64
// инициализация и основное условие
if b := float32(a); b > float32(0.1) {
    fmt.Println("Var a is GT float32(0.1)")
} 
```
Условие в данном примере может перестать выполняться, если добавить ещё один ноль: 0.100000001. Тип float32 обеспечивает точность в восемь десятичных чисел, в то время как точность float64 составляет около 15 чисел.

## Условие switch — case
```go
var a int

switch a {
case 1:
    fmt.Println("1")
case 2:
    fmt.Println("2")
case 3, 4:
    fmt.Println("3 or 4")
default:
    fmt.Println("Default case")
} 
```
Конструкция switch — case позволяет избежать дублирования else if. Проверка условий идёт сверху вниз и слева направо, поэтому в примере выше условия будут проверяться в таком порядке: 1, 2, 3, 4.

Наличие блока default необязательно — его можно опустить, если не требуется описывать «стандартное» поведение. Этот блок выполнится, если ни одно из условий не отработало.

Основное условие switch может быть не задано явно:
```go
var a int

switch {
case a == 100:
    fmt.Println("EQ 100")
case a > 0:
    fmt.Println("GT 0 AND NEQ 100")
case a < 0:
    fmt.Println("LT 0 AND NEQ 100")
} 
```
В этом примере важен порядок условий case: если переместить a == 100 в конец, то a > 0 всегда будет срабатывать первым для положительных чисел. Такая форма оператора аналогична множественному else if.

Внутри switch можно объявить локальную переменную, доступную только в пределах области видимости оператора:
```go
a := 6
switch b := a % 5; {
case b == 0:
    fmt.Println("Кратно 5")
default:
    fmt.Printf("Остаток от деления на 5: %d", b)
}
```
Чтобы досрочно прервать выполнение case, используют ключевое слово break. Это бывает полезно, когда внутри case есть условные конструкции. В Go нет необходимости явно указывать break в конце каждого case, так как следующий блок case автоматически не выполнится при совпадении условия.

Когда нужно всё-таки выполнить следующий блок, используют ключевое слово fallthrough. Если указать его в конце блока кода, то после него будет выполнен блок в следующем case или default.
```go
a := -100
switch {
case a > 0:
    if a % 2 == 0 {
        break
    }
    fmt.Println("Odd positive value received")
case a < 0:
    fmt.Println("Negative value received")
    fallthrough
default:
    fmt.Println("Default value handling")
} 
```
У ключевого слова fallthrough есть особенности:
- его можно использовать только в последней строке case, иначе будет ошибка компиляции;
- оно игнорирует условие следующего по порядку case.



# Циклы
Опуская области применения циклов, рассмотрим их формы в языке Go.
В программировании для циклов используют конструкции `for`, `while`, `do — while` и другие.
Создатели Go придерживаются правила «чем проще, тем лучше», поэтому для всех видов цикла в языке есть только одно ключевое слово — `for`.
![img](./assets/cycles.png)

## Бесконечный цикл
```go
for {
    // код, выполняемый внутри бесконечного цикла
}
```

Такой цикл чаще всего встречается в worker-паттерне: фрагмент кода должен выполняться до завершения процесса или потока, пока не будет прерван внешним событием.

Использовать фигурные скобки `{ }` для обозначения области видимости цикла обязательно.


## Трёхкомпонентный цикл
```go
// создаём переменную
v := 0
// 
for i := 1; i < 10; i++ {
    // наращиваем переменную
    v++
}
// выводим результат на экран
fmt.Println(v)
```

Классическая форма цикла состоит из трёх компонентов:
- `i := 1` — инициализация (pre-действие): выполняется единожды при входе в scope цикла;
- `i < 10` — основное условие: пока условие true, итерации будут продолжаться;
- `i++` — post-действие: выполняется по завершении каждой итерации цикла.

Заполнять каждую компоненту необязательно — можно опускать.

Есть ещё два варианта бесконечного цикла, но в форме трёх компонент:
```go
for ;; {}
for ; true; {}
```

Компоненты цикла могут принимать более комплексный вид:
```go
for a, b := 5, 10; a < 10 && b < 20; a, b = a + 1, b + 2 { 
    // do stuff
}
```

## Цикл while
```go
// создаём переменную
i := 0
// описываем предусловие
for i < 5 {
    // наращиваем переменную
    i++
}
// выводим результат на экран
fmt.Println(i)
```
 
Цикл `while` похож на трёхкомпонентный, но здесь оставлено только основное условие.


## Цикл range
```go
// создаём массив
array := [3]int{1, 2, 3}
// итерируемся
for arrayIndex, arrayValue := range array {
    fmt.Printf("array[%d]: %d\n", arrayIndex, arrayValue)
}
```

Цикл `range` используется для комплексных типов — слайса и мапы (map).
Подробнее об этом цикле расскажем в следующей теме, посвящённой композитным типам.


## Ключевые слова break и continue
Текущую итерацию цикла можно прервать ключевыми словами:
- `break` — выход из цикла;
- `continue` — переход к следующей итерации цикла (вызов post-действия, если оно задано).

Для примера посчитаем сумму всех чётных чисел от 0 до заданного предела:
```go
sum, limit := 0, 100
for i := 0; true; i++ {
    if i % 2 != 0 {
        continue // переход к следующему числу, так как i — нечётное
    }
    
    if sum + i > limit {
        break // выход из цикла, так как сумма превысит заданный предел
    }
    
    sum += i
}
fmt.Println(sum)
``` 

Ключевые слова `break` и `continue` относятся к ближайшему по области видимости циклу.


## Метки
В языке Go есть метки (labels), которые позволяют перемещаться к разным частям кода.

Метку можно указать для операторов:

- `break;`
- `continue;`
- `goto` (безусловный оператор перехода, позволяет перейти в любое место кода).

Приведём пример для `break`:
```go
outerLoopLabel:
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            fmt.Printf("[%d, %d]\n", i, j)
            break outerLoopLabel
        }
    }
    fmt.Println("End")
```
```
[0, 0]
End
```

Здесь `break outerLoopLabel` прерывает выполнение внешнего цикла.

А вот пример для continue:
```go
outerLoopLabel:
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            fmt.Printf("[%d, %d]\n", i, j)
            continue outerLoopLabel
        }
    }
    fmt.Println("End")
```
```
[0, 0]
[1, 0]
[2, 0]
[3, 0]
[4, 0]
End
```

Здесь continue `outerLoopLabel` вызывает переход к следующей итерации внешнего цикла. Если заменить `continue outerLoopLabel` на `break`, результат будет аналогичный.

Ключевые слова `break` и `continue` без указания метки относятся к текущей (ближайшей) области видимости кода.

Посмотрите, как можно вывести чётные числа в диапазоне [0:20] с указанием десятка.
```go
group := 0
for i := 0; i < 20; i++ {
    switch {
    case i % 2 == 0:
        if i % 10 == 0 {
            group++
            break // break относится к ближайшему switch
        }
        fmt.Printf("%02d: %d\n", group, i)
    default:
    }
}
```
```
01: 2
01: 4
01: 6
01: 8
02: 12
02: 14
02: 16
02: 18
```
Использование меток в Go, как и во многих других языках, — тема вечных споров. Считается, что метки делают код неочевидным, превращают в так называемый спагетти-код



# Указатели

Все данные программы, включая переменные, хранятся в памяти компьютера. Нумерация поддерживает порядок в ячейках, и такие номера называются адресами. Каждая переменная имеет адрес в виде целого положительного числа.
Если нужно передать переменную из одной части программы в другую, хватит обычного копирования:
```go
a := 5

var b int
b = a
```

Значение переменной `а` полностью скопировалось в `b`.

В плане удобства это далеко не универсальный способ.
Во-первых, размер переменной `a` может быть очень большим, копирование займёт много времени.
Во-вторых, иногда копии может быть недостаточно и нужно получить саму переменную — к примеру, чтобы изменить её значение.

> Тогда на помощь приходят указатели. Если вы знакомы с языком С, то легко разберётесь и с указателями в Go, в то время как программистам на Python придётся вникать в новую тему.

Итак, если у каждой переменной есть адрес, мы можем передавать его, а не сами данные, хранящиеся в ячейке памяти.
За хранение значения адреса переменной в Go отвечают указатели.
Данные любого типа хранятся в виде двоичных чисел, поэтому для определения конкретного типа данных в ячейке памяти указатель сам имеет соответствующий тип.

Синтаксис переменной типа «указатель» очень простой:
```go
var p *int
```
 
Здесь создали переменную типа «указатель на целое число». В Go можно создать указатель на любой тип данных.

Физически указатель — это ячейка памяти, хранящая адрес ячейки, на которую «смотрит» указатель.
После создания указатель не «смотрит» ни на одну ячейку памяти в компьютере и имеет нулевое значение.
Оно выглядит как `nil`.

Для того чтобы присвоить указателю значение (адрес какой-либо переменной), используется операция взятия адреса `&`:
```go
var a int = 5
p := &a

fmt.Println(a,p) //a=5 p=0xc0000b2008
```

Значение указателя на 64-битном компьютере — это 64-битное число.
Именно размер указателя на данной системе задаёт характеристику битности компьютера.

На разных платформах значение указателя `p` будет разным.
Именно поэтому значение указателя не имеет смысла за пределами программы.

Чтобы получить значение указателя, в памяти должна быть переменная, на которую он «смотрит». Такое значение называется адресуемым (adressable). С константами сложнее — у них забрать адрес не получится.
```go
const c = 5
p1 := &"abc" // ошибка компиляции
p2 := &с // ошибка компиляции
```
 
Тип переменной, на которую создаётся указатель, должен соответствовать типу указателя.
```go
var p *int
var a int = 5
var b string = "abc"
p = &a 
p = &b // ошибка компиляции
```

Литералы композитных типов создают в памяти переменную соответствующего типа, поэтому указатель можно создать вот так:
```go
type A struct {
  IntField int
}
// Литерал А{} создаёт в памяти переменную типа А. Затем от неё берётся указатель
p := &A{ 
  IntField: 10,
}
```

А ещё в Go есть встроенная функция `new()`. В качестве параметра ей передаётся тип, а возвращается указатель на новую переменную соответствующего типа.
```go
type A struct {
    IntField int
}

p := new(A) //  то же самое, что и &A{}
```

Указатели ведут себя так же, как и обычные переменные. Их можно копировать, присваивая другим переменным тип указателя, передавать и возвращать в функции, а также создавать указатели уже на них.

Тип указателя на указатель описывается как `**T`, например `**int`.

Чтобы получить или изменить значение, хранящееся по указателю, применяют оператор **разыменования (dereference)** `*`.
```go
i := 42
p := &i
fmt.Println(*p) // читаем значение переменной i через указатель p
*p = 21         // записываем в переменную i значение 21 через указатель p
```

Вызов оператора разыменования на `nil`-указателе приведёт к панике на этапе исполнения кода, и программа откажется работать дальше.
```go
var p *int
fmt.Println(*p) // panic: runtime error: invalid memory address or nil pointer dereference
``` 


## Указатели и структуры
Для указателей на структуры в Go есть возможность неявного разыменования при доступе к полям структуры.
```go
type A struct {
    IntField int
}

p := &A{}
p.IntField = 42 // вместо (*p).IntField = 42 
```


## Сравнение указателей
Для указателей определены операторы сравнения (`==`, `!=`).
Два указателя равны, если они указывают на один и тот же объект в памяти либо если оба равны `nil`.


## Когда стоит использовать указатели
- Когда нужно изменить значение переменной из вызываемой функции. Если передать переменную по значению, все модификации внутри функции применятся к локальной копии и оставят исходную переменную неизменной.
    ```go
    incrementCopy := func(i int) {
      i++
    }
    
    increment := func(i *int) {
      (*i)++
    }
    
    i := 42
    
    incrementCopy(i)
    fmt.Println(i) // 42
    
    increment(&i)
    fmt.Println(i) // 43
    ```
   
- Когда нужно подчеркнуть, что значение может отсутствовать.
  Например, есть функция, которая возвращает запись о пользователе `type User struct{...}` по его идентификатору. Результат-указатель даёт понять, что не по всем идентификаторам может быть найден пользователь. Пример функции с такой сигнатурой:
    ```go
    func FindUser(id UserID) *User
    ```

- Когда вы работаете с ресурсами вроде файловых дескрипторов или сокетов. 
  Копирование таких переменных может быть связано с исчерпанием системных ресурсов или вообще не производиться.
- Когда вы работаете с большими переменными и на копирование по стеку затрачивается больше ресурсов, чем на сборку мусора от указателей.


## Когда не стоит использовать указатели
- Когда хочется ускорить приложение и кажется, что копирование структур — слишком дорогая операция.
  До тех пор, пока нет тестов, однозначно показывающих, что указатели повышают производительность, лучше не пытаться оптимизировать.
  Вероятнее всего, напрасно потратите силы или снизите производительность системы, увеличив расходы на сборку мусора.
- Задумываться о замене передачи по значению на передачу по указателю стоит, когда размер структуры достигает порядка сотен байт.
- Когда множество указателей в памяти сильно нагружают сборщик мусора.
  Такое может произойти, к примеру, при создании собственной `in-memory` базы данных.


## Сравнение указателей в Go и C/С++
Синтаксис указателей в Go идентичен побратимам из С, как и многие другие параметры.
Однако есть пара важных различий.

Указатели в Go не имеют адресной арифметики.
Несмотря на то что указатель хранит адрес, который является числом, к нему нельзя применять арифметические операции.
Это не относится к недостаткам, потому что было сознательно убрано для повышения безопасности кода.

Указатель может «смотреть» не на любой участок памяти — только на существующий и соответствующий типу указателя.

По сути указатель близок к иммутабельности — его можно создать и присвоить адреса существующих переменных.
В С это реализовано гораздо шире.

Сборщик мусора, одна из ключевых фишек Go, не сможет удалить переменную, пока на неё «смотрит» какой-либо указатель.
Поэтому можно обойтись без ручного высвобождения памяти операцией `free`.


## Пример работы с указателями
Представим некоторую структуру, которая описывает пользователя:
```go
type Person struct {
  Name string
  Age int
  lastVisited time.Time
}  
```

В поле `LastVisited` нужно сохранять дату последнего посещения.
Напрямую сделать это нельзя, ведь поле неэкспортируемое.
Без указателей функция выглядела бы примерно так:
```go
func GetPersonWithLastVisited(p Person) Person {
    return Person{
        Name:        p.Name,
        Age:         p.Age,
        lastVisited: time.Now(), // time.Now() возвращает текущее время
    }
}

p := Person{
  Name: "Alex",
  Age: 25,
  lastVisited: time.Time{}, // пустое значение времени — пользователь ещё не посещал наш сервис
}

p = GetPersonWithLastVisited(p) 
```

У такого подхода много недостатков.
Структура сначала копируется в функцию, потом создаётся новая структура, в неё копируются поля старой, а затем результат должен быть скопирован в старую структуру.
Кроме того, изменения в структуре потребуют изменений в коде функции, даже если логически её это не касается.

C указателями всё становится проще:
```go
func UpdatePersonWithLastVisited (p *Person )  {
  p.lastVisited = time.Now() 
} 

p := Person{
  Name: "Alex",
  Age: 25,
  lastVisited: time.Time{},
}

UpdatePersonWithLastVisited(&p)
```
 
Здесь в функцию был передан указатель на переменную, что позволило изменить её поле без лишнего копирования.
Такая функция работает быстрее, а код становится проще.

В следующих уроках подробнее расскажем о функциях-методах, которые позволяют решить эту задачу более изящно.
Само собой, при участии указателей.


## Дополнительные материалы
[Подробная статья о том, как Go работает с памятью](https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d)
[How large should a struct be before you should pass by reference for performance?](https://www.reddit.com/r/golang/comments/rcnyhr/how_large_should_a_struct_be_before_you_should/)
[Наглядное разъяснение указателей](https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back)



# Массивы
**Массив** — это последовательность фиксированной длины, состоящая из элементов одного типа. 
Массивы используются для работы с набором элементов, количество которых не изменяется, и там, где нужно иметь набор однотипных элементов известной длины.

Представим, что у нас есть задача хранить набор значений: например, среднесуточную температуру за каждый день недели (всегда 7 дней).
Тогда здесь можно объявить массив:
```go
var lastWeekTemp [7]int
```

Число в скобках определяет длину массива, а литерал после скобок — тип элементов.

В Go количество элементов в массиве — это часть типа, то есть массивы `[3]int` и `[5]int` относятся к разным типам.

Чтобы определить в коде такую переменную, компилятор выделит в памяти область, размер которой будет определяться количеством элементов, умноженным на размер элементов.
Каждый элемент будет проинициализирован значением по умолчанию.

Все элементы в памяти расположатся последовательно, поэтому доступ к ним будет иметь константную сложность O(1).
Для обращения к элементам массива используются квадратные скобки `[]`:
```go
tempOnWednesday := lastWeekTemp[2]
``` 

В Go индексация массивов начинается с нуля, как и в большинстве других языков программирования.
Довольно часто встречается ситуация, когда при объявлении массива требуется задать значения массива сразу. 
В Go можно совместить объявление и инициализацию в одной конструкции.

Инициализация производится с помощью литерала массива:
```go
thisWeekTemp := [7]int {-3,5,7} // [-3 5 7 0 0 0 0]
rgbColor := [3]uint8 {255,255,128} // [255 255 128]
```

Здесь указывается сначала тип массива `[7]int`, а затем в фигурных скобках через запятую — элементы массива, то есть список инициализации.

Для компилятора тип массива в приоритете: если вы указали массив из семи элементов, но в списке инициализации всего три, то оставшиеся элементы будут проинициализированы значениями по умолчанию.

Компилятор следит за размером списка инициализации, и уже такую конструкцию скомпилировать не получится:
```go
rgbColor := [3]uint8{1, 2, 3, 4} // array index 3 out of bounds [0:3]
```

Количество элементов в массиве может быть выведено автоматически по длине списка инициализации. 
Для этого используется следующая конструкция:
```go
rgbColor := [...]uint8{255,255,128} // [255 255 128] len = 3
rgbaColor := [...]uint8{255,255,128,1} // [255 255 128 1] len = 4
```

Три точки указывают компилятору, что размер массива должен быть выведен исходя из размера списка инициализации.

Иногда возникает необходимость указать в списке инициализации только один или несколько элементов массива, а другие не трогать.

Если бы вам понадобилось указать значение среднесуточной температуры в воскресенье, код вряд ли порадовал бы своей утончённостью:
```go
thisWeekTemp := [7]int {0,0,0,0,0,0,11} // [0 0 0 0 0 0 11] 
```

Для больших массивов это превратилось бы в нечитаемую конструкцию:
```go
var thisWeekTemp [7]int // [0 0 0 0 0 0 0]
thisWeekTemp[6] = 11 // [0 0 0 0 0 0 11] 
```

Однако в списке инициализации можно указать только нужные элементы и их индексы. 
Индекс и значение указываются через двоеточие.
```go
thisWeekTemp := [7]int {6:11, 2:3} // [0 0 3 0 0 0 11] 
```

Размер массива может быть получен встроенной функцией len. 
Так как размер массива известен на этапе компиляции, то вычисление этой функции при компиляции подменяется конкретным значением.

Если попытаться обратиться к элементу массива за пределами его размера, то сработает механизм защиты памяти в Go и начнётся паника.
В отличие от языка C, компилятор и рантайм Go контролируют выход за пределы массива, не позволяя обратиться к недопустимым областям памяти. 


## Многомерные массивы
**Многомерные массивы** создаются так же, как и одномерные. 
Каждая размерность массива указывается в отдельных квадратных скобках.
```go
var thisMonthTemp [4][7]int // массив из четырёх недель, каждая из которых — массив из семи дней  
```

Многомерные массивы удобно представлять себе как массив массивов:
```go
var rgbImage [1080][1920][3]uint8 // изображение — это массив из 1080 строк длиной в 1920 пикселей. Каждый пиксель — массив из трёх байт
            // 1080 — размер массива
            // [1920][3]uint8 — тип элемента 
```

Доступ к элементам многомерного массива осуществляется через квадратные скобки:
```go
line := rgbImage [2] // 3-я строка в изображении
pixel := rgbImage[2][3] // 4-й пиксель в третьей строке изображения
red :=  rgbImage[2][3][1] // значение синей компоненты (второй байт) 4-го пикселя в третьей строке изображения 
```


## Обход значений массива
Для работы с массивами часто используются циклы. Например, когда нужно посчитать среднюю температуру (округлённо) в течение недели:
```go
var weekTemp = [7]int{5,4,6,8,11,9,5} 

sumTemp := 0

for i:= 0; i < len(weekTemp); i++ {
    sumTemp += weekTemp[i]
}

average := sumTemp/len(weekTemp)
```

Здесь вводится дополнительная переменная `i`, которая увеличивается на каждом шаге.
В Go есть более удобная конструкция `for range`, которая позволяет обойти элементы массива последовательно, не используя дополнительные переменные:
```go
var weekTemp = [7]int{5, 4, 6, 8, 11, 9, 5} 

sumTemp := 0

for _, temp := range weekTemp {
    sumTemp += temp
}

average := sumTemp/len(weekTemp)
```

Оператор `range` на каждой итерации возвращает индекс и значение следующего элемента в массиве.

> Обратите внимание на следующий важный момент: конструкция `_, temp := range weekTemp` создаёт новую переменную `temp`, тип которой будет определяться типом элемента массива.

Этой переменной на каждой итерации цикла будет присваиваться следующее значение из массива.
Если изменить значение переменной `temp`, то это не повлияет на значения в массиве.

Чтобы получить доступ к элементу массива, понадобится индекс:
```go
var weekTemp = [7]int{5, 4, 6, 8, 11, 9, 5} 
// weekTemp [5 4 6 8 11 9 5]
for _, temp := range weekTemp {
   temp = 0 
}
// weekTemp [5 4 6 8 11 9 5] ! — значения не изменились
// если значение элемента не используется, можно опустить вторую переменную
for i := range weekTemp {
   weekTemp[i] = 0 
}
// weekTemp [0 0 0 0 0 0 0] ! — значения изменились
```

Переменные массивов можно присваивать друг другу, однако у них должен быть одинаковый тип, причём количество и тип элементов должны совпадать.

В процессе присваивания выполняется полное копирование массива, и если программа обрабатывает достаточно большие массивы данных, то эти копирования могут существенно замедлить работу программы и увеличить потребление памяти.

**Передача массива** (как и переменной любого другого типа) в функцию — это копирование его значения в переменную аргумента функции. Здесь тоже будет полное копирование.

> С циклом `for range` связан ещё один важный момент — операнд `range` копируется во временную переменную, которая уже используется для обхода.

Это также может замедлить выполнение программы для массивов, поэтому следует использовать взятие указателя, чтобы не простаивать:
```go
for _, temp := range &weekTemp {
   temp = 0 
}
```

Об указателях подробно рассказано в соответствующем уроке.


## Преимущества применения массивов
1. Элементы массива всегда располагаются в памяти последовательно, этому радуется процессор и ускоряет выполнение программы.
2. Массивы имеют фиксированную длину, поэтому выделение памяти под массив происходит ровно один раз в момент его объявления.
3. Время доступа к элементам массива минимальное.
4. Go проверяет выход за пределы массива на этапе компиляции, если может вычислить значение индекса элемента на этапе компиляции, и во время исполнения программы. В первом случае будет ошибка компиляции, а во втором — паника. Панику лучше не допускать.


## Недостатки применения массивов
1. Массивы могут быть только фиксированной длины: если количество элементов нам заранее неизвестно, память придётся выделять с запасом.
2. Массивы передаются и присваиваются с полным копированием элементов, что грозит внезапным ухудшением производительности и увеличенным расходом памяти.
3. Для обработки массивов разных габаритов придётся писать разные функции (если не используются дженерики).

Массивы следует применять крайне обдуманно, когда размеры вашего массива точно известны на этапе компиляции.
Это позволяет ускорить работу программы.

Для того чтобы исправить недостатки массивов, в Go введены слайсы, которые будут рассмотрены ниже.

## Слайсы
Раз длина массива — это часть его типа, то массивы не подходят для хранения коллекций данных динамического размера.
Эту задачу решает другой тип данных, который гораздо чаще используется на практике, — **слайс (от англ. slice)**, или срез.
Кроме того, слайс избавит нас от проблемы копирования массивов для присваивания.

**Слайс** — это последовательность переменной длины, состоящая из элементов одного типа.
Тип слайса записывается как тип массива без указания размера.
Можно инициализировать переменную типа «слайс» значениями, но, в отличие от массива, переменная без инициализации равна nil.
```go
var mySlice []int
```
 
Слайс очень похож на `list` в языке Python, но имеет свои особенности.

Слайс — это обёртка над указателем массива, и в Go слайс используется как структура следующего вида:
- указатель на первый элемент базового массива — `ptr`;
- длина слайса — `len`, количество элементов в слайсе;
- ёмкость слайса — `cap`, количество элементов в массиве.

![img](./assets/slice.png)

Параметры слайса `len` и `cap` могут быть получены с помощью вызова соответствующих встроенных функций `len()` и `cap()`.

Если просто объявить такую структуру, то она будет равна `nil`.

Для создания слайса используется встроенная функция `make()`:
```go
mySlice := make([]TypeOfelement, LenOfslice, CapOfSlice)
mySlice := make([]int,0) // слайс [], базовый массив []
mySlice := make([]int,5) // слайс [0 0 0 0 0], базовый массив [0 0 0 0 0]
mySlice := make([]int,5,10) // слайс [0 0 0 0 0], базовый массив [0 0 0 0 0 0 0 0 0 0]
```

Аргументы функции `make`:
1. Тип слайса (пустые квадратные скобки и тип элемента слайса).
2. Длина слайса. Если не передана, то по умолчанию равна нулю.
3. Ёмкость слайса — размер базового массива. Если значение не передано, то по умолчанию равна длине слайса.

Функция `make` создаёт массив длиной `cap` и записывает указатель на него в структуру слайса.
Также она заполняет поля `len` и `cap` в этой структуре и возвращает её в виде переменной типа «слайс».

Даже если `len` и `cap` переданы как нулевые, сама структура уже не будет равна `nil`.
Она будет выделена в памяти, и указатель на базовый массив получит значение, отличное от `nil`.

Если передать в функцию `make` параметр `cap` меньше `len`, то будет вызвана ошибка компиляции или паника во время исполнения.

Слайс может быть создан из композитного литерала так же, как и массив. Единственное отличие — не указываем размер массива:
```go
s = []int{1, 2, 3}  // [1 2 3]
```

Длина и ёмкость слайса будут равны композитному литералу.

Новый слайс может быть создан на основе уже существующего слайса или массива.
Для этого используется операция взятия слайса.
Она выполняется с помощью двух скобок с двоеточием `[i:j]`, где `i` — индекс первого элемента нового слайса, а `j` — индекс следующего элемента, не входящего в новый слайс.

Допускается не указывать `i` и `j` — в таком случае `i` по умолчанию будет равен 0, `j` — равен длине массива или слайса.

Таким образом, `[:]` вернёт слайс всего массива, `[:k]` — от начала и до k-го элемента, `[k:]` — от k-го элемента до конца массива.

`i` и `j` должны быть неотрицательны и меньше `len`, иначе будет вызвана ошибка компиляции или паника.

Рассмотрим пример с массивом среднесуточных температур из раздела про массивы.
```go
weekTempArr := [7]int{1,2,3,4,5,6,7}
workDaysSlice := weekTempArr[:5]
weekendSlice := weekTempArr[5:]
fromTuesdayToThursDaySlice := weekTempArr[1:4] 
weekTempSlice := weekTempArr[:]

fmt.Println(workDaysSlice, len(workDaysSlice), cap(workDaysSlice)) // [1 2 3 4 5] 5 7
fmt.Println(weekendSlice, len(weekendSlice), cap(weekendSlice)) // [6 7] 2 2 
fmt.Println(fromTuesdayToThursDaySlice, len(fromTuesdayToThursDaySlice), cap(fromTuesdayToThursDaySlice)) // [2 3 4] 3 6 
fmt.Println(weekTempSlice, len(weekTempSlice), cap(weekTempSlice)) // [1 2 3 4 5 6 7] 7 7 
```

### Задание 3 для самопроверки
> Попробуйте изменить какой-либо элемент в одном из этих слайсов через операцию []. 
> Убедитесь, что значения изменились и в других слайсах.
> Все слайсы в этом примере действительно смотрят на один и тот же базовый массив.
> Обратите внимание на ёмкость — она равна размеру базового массива, кроме первых элементов.

> В слайс workDaysSlice взяли элементы с 0 по 4, однако 5 и 6 по-прежнему остаются в массиве.


## Изменение размеров слайса
Как вы уже знаете, слайс — последовательность элементов динамического размера.

Уменьшение размера слайса производится через операцию взятия слайса.
Результат взятия можно присвоить этому же слайсу:
```go
s := []int{1,2,3} // [1 2 3]
s = s[:len(s)-1] // [1 2]
```

Ёмкость массива при этом не изменяется.

Для увеличения размера слайса используется встроенная функция `append`.
Она принимает переменную типа «слайс» и одну или несколько переменных типа элемента слайса, затем возвращает новый слайс, который состоит из копии переданного слайса и переданных в него элементов.

> Внимание: `append` не изменяет переданный ей слайс, а создаёт новый на основе переданного.

Рассмотрим пример:
```go
a := []int{1, 2, 3}
fmt.Println(a, len(a), cap(a)) // [1 2 3] 3 3
b := append(a, 4)
fmt.Println(a, len(a), cap(a)) // [1 2 3] 3 3
fmt.Println(b, len(b), cap(b)) // [1 2 3 4] 4 6
``` 

После выполнения `append` значение `a` не изменилось, зато `b` увеличилось на один элемент, и его длина стала равна 4, а ёмкость 6.

Дело в механике `append`: если ёмкость слайса позволяет разместить добавляемые элементы — то есть разница между длиной слайса и его ёмкостью больше или равна количеству размещаемых элементов, — то `append` создаёт новый слайс, используя тот же базовый массив, а новые элементы записываются в него сразу после имеющихся элементов слайса.

Если же ёмкость слайса не позволяет разместить эти элементы, то создаётся новый базовый массив вдвое больше существующего, в него копируются все элементы переданного слайса и добавляются новые.
Именно поэтому в нашем примере ёмкость слайса увеличилась с 3 до 6.

Такой алгоритм работы применяется не только в Go, но и в Python, С++ и многих других языках программирования.
Это связано с тем, что выделение нового участка памяти во время работы программы — достаточно дорогостоящая операция с точки зрения затрат вычислительных ресурсов, и выгоднее держать немного памяти про запас.
Ёмкость базового массива как раз и задаёт такой запас.

Чтобы соединить два слайса, нужно распаковать слайс `append(a,b...)`.
Функция принимает некоторое количество отдельных элементов и преобразует слайс в список через распаковку.

Рассмотрим ещё несколько примеров.
```go
s := make([]int, 4, 7) // [0 0 0 0], len = 4 cap = 7
// 1. Создаём слайс s с базовым массивом на 7 элементов. 
// Четыре первых элемента будут доступны в слайсе.

slice1 := append(s[:2], 2, 3, 4)  
fmt.Println(s, slice1) // [0 0 2 3] [0 0 2 3 4]
// 2. Берём слайс из первых двух элементов s и добавляем к ним три элемента.
// Так как суммарная длина полученного слайса (len == 5) меньше ёмкости s[:2] (cap == 7), 
// то базовый массив остаётся прежним.
// Слайс s тоже изменился, но его длина осталась прежней

slice2 := append(s[1:2], 7) 
fmt.Println(s, slice1, slice2) // [0 0 7 3] [0 0 7 3 4] [0 7]
// 3. Здесь также базовый массив остаётся прежним, изменились все три слайса

slice3 := append(s, slice1[1:]...)
fmt.Println(len(slice3), cap(slice3))  // 8 14
// 4. Длина s и slice1[1:] равна 4, длина нового слайса будет равна 8,  
// что больше ёмкости базового массива.
// Будет создан новый базовый массив ёмкостью 14,
// ёмкость нового базового массива подбирается автоматически 
// и зависит от текущего размера и количества добавленных элементов

// 5. Легко проверить, что slice3 ссылается на новый базовый массив
s[1] = 99
fmt.Println(s, slice1, slice2, slice3) 
// [0 99 7 3] [0 99 7 3 4] [99 7] [0 0 7 3 0 7 3 4] 
Так этот процесс выглядит на картинке:
```

Так этот процесс выглядит на картинке:
![img](./assets/slices_append.png)

Здесь не очень понятно, будут ли новые слайсы ссылаться на тот же базовый массив или отправят свои копии в новый массив.
Поэтому на практике функцию `append` рекомендуют лишь для присвоения слайса самому себе: `s = append(s, b)`.

> Чтобы использовать слайсы, нужно понимать механизм их работы.
> В противном случае вы будете получать ошибки, которые очень трудно найти.
> Старайтесь избегать ситуаций, когда на базовый массив ссылается несколько слайсов и происходит добавление или изменение элементов.

Операция взятия слайса поддерживает и третий параметр: `[low:high:max]` — третьим параметром указывается ёмкость базового массива, необходимая для создания нового слайса.
При этом `max` должна быть меньше или равна ёмкости базового массива или слайса.
Вряд ли вы встретите аналогичный пример на практике, но знать про него будет полезно.


## Присваивание слайса и передача в функции
Присвоение друг другу переменных слайса даже самого внушительного размера не потребляет больших вычислительных мощностей, потому что сама по себе структура слайса всегда содержит всего три поля: `ptr`, `len` и `cap`.
Однако надо держать в уме, что эти переменные ссылаются на один и тот же массив, поэтому изменение в данных одного слайса может повлечь за собой изменение другого.

При передаче слайса в аргументы функции структура слайса копируется в локальную переменную внутри функции.
Это позволяет изменить данные внутри слайса, переданного в функцию.
Но если нужно добавить или удалить элементы из слайса, то эти изменения затронут только локальную переменную слайса.

Для примера возьмём пару функций из стандартной библиотеки:
```go
s := []int{5, 4, 1, 3, 2}
sort.Ints(s)
fmt.Println(s) // [1 2 3 4 5]
```

Функция `sort.Ints` сортирует полученный слайс целых чисел по возрастанию.
Она не меняет размер и ёмкость слайса, поэтому может спокойно работать с ним.
```go
    // Пример взят из стандартной библиотеки
    import (
    "bytes"
    "fmt"
)

func main() {
    bSlice := []byte(" \t\n a lone gopher \n\t\r\n")
    fmt.Printf("%s", bytes.TrimSpace(bSlice)) // a lone gopher
    fmt.Printf("%s", bSlice)  // \t\n a lone gopher \n\t\r\n 
    
}
```
 
Функция `bytes.TrimSpace` принимает _**слайс байт**_ и возвращает новый слайс байт, откуда были удалены начальные и конечные пробельные символы.
Размер слайса должен измениться, а значит, `bSlice` останется нетронутым. В итоге `bytes.TrimSpace` подарит нам новый слайс.


## Копирование слайсов
Для копирования элементов из одного слайса в другой применяется функция `copy([]T dest, []T src)`, где `dest` — это слайс-приёмник, а `src` — слайс-источник.
Эта функция только перезаписывает элементы, поэтому количество скопированных элементов будет равно меньшей длине из двух слайсов.
```go
var dest []int
dest2, dest3 := make([]int, 3),  make([]int, 5)
src := []int{1, 2, 3, 4}
copy(dest, src)
copy(dest2, src)
copy(dest3, src)
fmt.Println(dest, dest2, dest3, src ) // [] [1 2 3] [1 2 3 4 0] [1 2 3 4]
```

## Обход слайсов и доступ к элементам
Обход слайсов и доступ к элементам слайса происходят точно так же, как и для массивов.
Чтобы добраться до элементов по индексу, используются квадратные скобки `[]`, циклы `for` и `for range`.


## Полезные приёмы для работы со слайсами
В отличие от других языков программирования, Go не щеголяет обилием функций для работы со слайсами.
Гоферы выкрутились и придумали несколько приёмов, которые позволяют решать частые задачи.

#### Удаление последнего элемента слайса:
```go
s := []int{1, 2, 3}
if len(s) != 0 { // защищаемся от паники
    s = s[:len(s)-1]
}
fmt.Println(s) // [1 2]
```

#### Удаление первого элемента слайса:
```go
s := []int{1,2,3}
if len(s) != 0 { // защищаемся от паники
    s = s[1:]
} 
fmt.Println(s) // [2 3]
```

#### Удаление элемента слайса с индексом `i`:
```go
s := []int{1,2,3,4,5}
i := 2

if len(s) != 0 && i < len(s)-1  { // защищаемся от паники
    s = append(s[:i], s[i+1:]...)
} 
fmt.Println(s) // [1 2 4 5]
```

#### Сравнение двух слайсов:
```go
s1 := []int{1,2,3}
s2 := []int{1,2,4}
s3 := []string{"1","2","3"}
s4 := []int{1,2,3}

fmt.Println(reflect.DeepEqual(s1,s2)) // false
fmt.Println(reflect.DeepEqual(s1,s3)) // false
fmt.Println(reflect.DeepEqual(s1,s4)) // true
```

## Заключение
Слайсы широко применяются в Go для реализации коллекций однотипных элементов, но требуют грамотного применения: без понимания их устройства вы можете нарваться на каверзные ошибки.

## Дополнительные материалы
[Go Slice Tricks Cheat Sheet](https://ueokande.github.io/go-slice-tricks/)
[Digital Ocean. Массивы и срезы в Go](https://www.digitalocean.com/community/tutorials/understanding-arrays-and-slices-in-go-ru)


