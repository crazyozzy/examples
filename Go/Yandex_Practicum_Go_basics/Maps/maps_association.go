// Ассоциативные массивы широко применяются при решении алгоритмических задач.
// Когда количество данных более нескольких десятков, поиск значения в map происходит эффективнее, чем в массиве.
// Опираясь на эту информацию, попробуйте решить следующую задачу, которую часто предлагают на собеседованиях.

// Дан массив целых чисел A и целое число k.
// Нужно найти и вывести индексы пары чисел, сумма которых равна k.
// Если таких чисел нет, то вернуть пустой слайс.
// Индексы можно вернуть в любом порядке.

package main

import (
	"fmt"
)

func main(){
	A := make([]int, 100)
	k := 20
	for i := 0; i < cap(A); i++ {
		A[i] = i + 1
	}

	map_A := make(map[int]int)

	for index, val := range A {
		if map_A[val] == 0 {
			map_A[val] = index
		}
	}

	for key, val := range map_A {
		if key == k - key {
			continue
		}
		i, ok := map_A[ k - key ]
		if ok {
			fmt.Printf("Индекс %d (%d) и %d(%d) == %d\n", val, key, i, k - key, k)
		}
	}
}



// Ответ:   
// func find(arr []int, k int) []int {
// 	// Создадим пустую map  
// 	m := make(map[int]int)
// 	// будем складывать в неё индексы массива, а в качестве ключей использовать само значение 
// 	for i, a := range arr {
// 		if j, ok := m[k-a]; ok { // если значение k-a уже есть в массиве, значит, arr[j] + arr[i] = k и мы нашли, то что нужно
// 			return []int{i,j}
// 		}
// 		// если искомого значения нет, то добавляем текущий индекс и значение в map
// 		m[a] = i
// 	}
// 	// не нашли пары подходящих чисел
// 	return nil
// }    
// // как можно заметить, алгоритм пройдётся по массиву всего один раз
// // если бы мы искали подходящее значение каждый раз через перебор массива, то пришлось бы сделать гораздо больше вычислений
