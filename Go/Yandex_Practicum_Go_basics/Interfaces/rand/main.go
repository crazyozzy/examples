// В последнем рассмотренном примере реализация функции Read не очень эффективна — генератор случайных чисел возвращает 64-битное число, то есть 8 байт.
// Из них используем только 1.

// Попробуйте реализовать более эффективное решение.
// Для упрощения примера считайте, что функция будет принимать только слайсы, длина которых кратна 8.
// Для преобразования числа в слайс байт можно использовать функцию из стандартной библиотеки binary.LittleEndian.PutUint64([ ]byte, uint64).

package main

import (
    "rand/randbyte"
    "fmt"
    "time"
)

func main() {

    // создаём генератор случайных чисел
    generator := randbyte.New(time.Now().UnixNano()) // в качестве затравки передаём ему текущее время, и при каждом запуске оно будет разным.

    buf := make([]byte, 8)

    for i := 0; i < 1; i++ {
        n, _ := generator.Read(buf) // единственный доступный метод, но он нам и нужен.
        fmt.Printf("Generate bytes: %v size(%d)\n", buf, n)
    }

}

// Ответ:
// // Read — реализация io.Reader
// func (g *generator) Read(bytes []byte) (n int, err error) { // error это тип ошибки, подробнее мы рассмотрим его в следующем разделе.
//     for i := 0; i+8 < len(bytes); i += 8 {
//         binary.LittleEndian.PutUint64(bytes[i:i+8], uint64(g.rnd.Int63()))
//     }
//     return len(bytes), nil
// }